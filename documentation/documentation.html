<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style>
p                                 {  width: 600px; }
.dropdown                         { position: relative;
                                    display: inline-block; }
.drp-content                      { display: none; 
                                    position: fixed;
                                    bottom: 10px; 
                                    right: 10px; 
                                    background-color: #ffcc00;
                                    max-width: 500px; 
                                    box-shadow: 0px 16px 16px 0px rgba(0,0,0,0.6);
                                    padding: 0px 6px; 
                                    z-index: 0; }
.dropdown:hover      .drp-content { display: block; 
                                    z-index: 2; }              
</style>
</head><body><center><table style="width: 600px; font-size:12px;"><tr><td><div style=" text-justify: inter-word; width: 600px; line-height: 17px; ">



















      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      



















<div style="text-align: center; color: inherit; font-size: inherit;"><p><span style="font-size: 120%;"><span style="font-size: 120%;"><span style="font-size: 120%;"><span style="font-size: 120%;"><span style="font-size: 120%;">Fragment</span></span></span></span></span></p></div>
<div style="text-align: center; color: inherit; font-size: inherit;"><p><span style="font-size: 120%;"><span style="font-size: 120%;">The Collaborative Spectral Synthesizer</span></span></p></div>
<div style="text-align: center; color: inherit; font-size: inherit;"><p>by Julien Verneuil - contact@fsynth.com</p></div>
<br>
<div style="text-align: center; color: inherit; font-size: inherit;"><p><span style="font-size: 120%;">This is the HTML documentation of the Fragment synthesizer.</span></p></div>
<div style="text-align: center; color: inherit; font-size: inherit;"><p>The PDF documentation can be found <a href="https://www.fsynth.com/pdf/fragment_documentation.pdf">here</a></p></div>
<div style="text-align: center; color: inherit; font-size: inherit;"><p><a href="https://www.fsynth.com"><img src="images/fsynth_ui.png" width="580"></a></p></div>
<br>
<div style="text-align: center; color: inherit; font-size: inherit;"><p><strong>Table of Contents</strong></p></div>
<a rel="tag" href="#sec1"><br><strong>1. Introduction</strong><br></a><a rel="tag" href="#subsec1_1"><div align="left" style="display: inline-block; width: 20px;"></div>1.1. History<br></a><a rel="tag" href="#subsec1_2"><div align="left" style="display: inline-block; width: 20px;"></div>1.2. Capabilities<br></a><a rel="tag" href="#subsec1_3"><div align="left" style="display: inline-block; width: 20px;"></div>1.3. System requirements<br></a><a rel="tag" href="#subsubsec1_3_1"><div align="left" style="display: inline-block; width: 40px;"></div>1.3.1.Browser<br></a><a rel="tag" href="#subsubsec1_3_2"><div align="left" style="display: inline-block; width: 40px;"></div>1.3.2.CPU<br></a><a rel="tag" href="#subsubsec1_3_3"><div align="left" style="display: inline-block; width: 40px;"></div>1.3.3.GPU<br></a><a rel="tag" href="#sec2"><br><strong>2. Concept</strong><br></a><a rel="tag" href="#subsec2_1"><div align="left" style="display: inline-block; width: 20px;"></div>2.1. Additive synthesis<br></a><a rel="tag" href="#subsec2_2"><div align="left" style="display: inline-block; width: 20px;"></div>2.2. The graphical score<br></a><a rel="tag" href="#sec3"><br><strong>3. Sessions</strong><br></a><a rel="tag" href="#subsec3_1"><div align="left" style="display: inline-block; width: 20px;"></div>3.1. Homepage and sessions history<br></a><a rel="tag" href="#sec4"><br><strong>4. FAS</strong><br></a><a rel="tag" href="#sec5"><br><strong>5. The user interface</strong><br></a><a rel="tag" href="#subsec5_1"><div align="left" style="display: inline-block; width: 20px;"></div>5.1. Dialogs<br></a><a rel="tag" href="#subsec5_2"><div align="left" style="display: inline-block; width: 20px;"></div>5.2. The information bar<br></a><a rel="tag" href="#subsec5_3"><div align="left" style="display: inline-block; width: 20px;"></div>5.3. The graphical score<br></a><a rel="tag" href="#subsubsec5_3_1"><div align="left" style="display: inline-block; width: 40px;"></div>5.3.1.Slice<br></a><a rel="tag" href="#subsec5_4"><div align="left" style="display: inline-block; width: 20px;"></div>5.4. The toolbar<br></a><a rel="tag" href="#subsec5_5"><div align="left" style="display: inline-block; width: 20px;"></div>5.5. The fragment inputs<br></a><a rel="tag" href="#subsec5_6"><div align="left" style="display: inline-block; width: 20px;"></div>5.6. The canvas input<br></a><a rel="tag" href="#subsec5_7"><div align="left" style="display: inline-block; width: 20px;"></div>5.7. The code editor<br></a><a rel="tag" href="#subsec5_8"><div align="left" style="display: inline-block; width: 20px;"></div>5.8. MIDI learn functionality<br></a><a rel="tag" href="#subsec5_9"><div align="left" style="display: inline-block; width: 20px;"></div>5.9. The session/global settings dialog<br></a><a rel="tag" href="#subsec5_10"><div align="left" style="display: inline-block; width: 20px;"></div>5.10. MIDI settings dialog<br></a><a rel="tag" href="#subsec5_11"><div align="left" style="display: inline-block; width: 20px;"></div>5.11. Recording dialog<br></a><a rel="tag" href="#subsec5_12"><div align="left" style="display: inline-block; width: 20px;"></div>5.12. Outline dialog<br></a><a rel="tag" href="#subsec5_13"><div align="left" style="display: inline-block; width: 20px;"></div>5.13. Session chat dialog<br></a><a rel="tag" href="#subsec5_14"><div align="left" style="display: inline-block; width: 20px;"></div>5.14. Uniforms dialog<br></a><a rel="tag" href="#sec6"><br><strong>6. How to produce sounds by programming your GPU</strong><br></a><a rel="tag" href="#subsec6_1"><div align="left" style="display: inline-block; width: 20px;"></div>6.1. OpenGL Shading Language<br></a><a rel="tag" href="#subsec6_2"><div align="left" style="display: inline-block; width: 20px;"></div>6.2. Pre-defined uniforms<br></a><a rel="tag" href="#subsec6_3"><div align="left" style="display: inline-block; width: 20px;"></div>6.3. The timbre<br></a><a rel="tag" href="#subsec6_4"><div align="left" style="display: inline-block; width: 20px;"></div>6.4. Drawing the fundamental<br></a><a rel="tag" href="#subsec6_5"><div align="left" style="display: inline-block; width: 20px;"></div>6.5. Drawing harmonics<br></a><a rel="tag" href="#subsec6_6"><div align="left" style="display: inline-block; width: 20px;"></div>6.6. Square and triangle waveform<br></a><a rel="tag" href="#subsec6_7"><div align="left" style="display: inline-block; width: 20px;"></div>6.7. Simulating pulse-width<br></a><a rel="tag" href="#subsec6_8"><div align="left" style="display: inline-block; width: 20px;"></div>6.8. Playing with a MIDI keyboard<br></a><a rel="tag" href="#subsec6_9"><div align="left" style="display: inline-block; width: 20px;"></div>6.9. Simple AR-like envelope<br></a><a rel="tag" href="#subsec6_10"><div align="left" style="display: inline-block; width: 20px;"></div>6.10. Morphing between parameters<br></a><a rel="tag" href="#subsec6_11"><div align="left" style="display: inline-block; width: 20px;"></div>6.11. ADSR envelope<br></a><a rel="tag" href="#subsec6_12"><div align="left" style="display: inline-block; width: 20px;"></div>6.12. Filters<br></a><a rel="tag" href="#subsubsec6_12_1"><div align="left" style="display: inline-block; width: 40px;"></div>6.12.1.Low-pass filter (LPF)<br></a><a rel="tag" href="#subsubsec6_12_2"><div align="left" style="display: inline-block; width: 40px;"></div>6.12.2.High-pass filter (HPF), Band-pass filter and Band-reject filter<br></a><a rel="tag" href="#subsec6_13"><div align="left" style="display: inline-block; width: 20px;"></div>6.13. Timbral possibilities<br></a><a rel="tag" href="#subsec6_14"><div align="left" style="display: inline-block; width: 20px;"></div>6.14. Delay effect<br></a><a rel="tag" href="#subsec6_15"><div align="left" style="display: inline-block; width: 20px;"></div>6.15. Sequence<br></a><a rel="tag" href="#subsec6_16"><div align="left" style="display: inline-block; width: 20px;"></div>6.16. Note on globalTime<br></a><a rel="tag" href="#sec7"><br><strong>7. Contributing</strong><br></a><a rel="tag" href="#sec8"><br><strong>8. Links</strong><br></a><a rel="tag" href="#sec9"><br><strong>9. Credits</strong><br></a>
<a id="sec1"></a><br><br><span style="font-size: 120%;"><span style="font-size: 120%;"><strong>1. Introduction</strong></span></span><br><br>
The <strong><a href="https://www.fsynth.com">Fragment synthesizer</a></strong> is a collaborative web-based musical instrument which allow direct manipulation of the sound spectrum by the use of on-the-fly GPU (Graphics Processing Unit) coding.<br><br>Fragment is stereophonic, polyphonic, multitimbral and support live coding of audio and visuals at the same time.<br><br>Fragment main synthesis method is additive, granular synthesis was successfully implemented as well but not yet available.<br><br>Fragment has many features making it a bliss to produce any kind of sounds, it is aimed at artists seeking a real-time creative environment with direct visual feedback and few limitations to experiment with, a programmable noise-of-all-kinds software.<br><br>Many videos of Fragment live sessions were recorded and are available on YouTube as a <a href="https://www.youtube.com/playlist?list=PLYhyS2OKJmqe_PEimydWZN1KbvCzkjgeI">playlist</a>.<br><br><br>
<a id="subsec1_1"></a><span style="font-size: 120%;"><strong>1.1. History</strong></span><br><br>
In 2009, i discovered the <a href="http://www.warmplace.ru/soft/ans/">Virtual ANS</a> synthesizer by <a href="http://www.warmplace.ru">Alexander Zolotov</a>,
a software emulation of the Russian photoelectronic synthesizer <a href="http://en.wikipedia.org/wiki/ANS_synthesizer">ANS</a> which was created by the Russian engineer <a href="http://en.wikipedia.org/wiki/Evgeny_Murzin">Evgeny Murzin</a> from 1938 to 1958.<br><br>I was blown away by the remarquable possibilities offered by the Virtual ANS which let you draw the sound spectrum over time, i then discovered programs such as MetaSynth or <a href="https://highc.org">HighC</a>, this is how i started to experiment with the "drawn sound" method.<br><br>Fragment started in 2015, when i was making the first prototype of a web-based ANS-like synthesizer software, a prototype of Fragment was made in a single week, 
the prototype was quite mature but lacked in features, i considered Fragment as a pretty failed experiment at the time.<br><br>In the summer 2016 while i was releasing the prototype source code, i played with it again and after tweaking the GLSL code, i was able to make some nice sounds, so i started to think about that prototype again and come up with many ideas that would make Fragment more functional and easier to use, the real work begun.<br><br>After many hours spent crafting the software, the first version of Fragment was released in January 2017, it was quite limited at that time, Fragment has now improved alot.<br><br><br>
<a id="subsec1_2"></a><span style="font-size: 120%;"><strong>1.2. Capabilities</strong></span><br><br>
<span><ul>
	<li> Powerful additive synthesizer
		<span><ul><li> Powered by WebAudio oscillators <li> Powered by <a rel="tag" href="#fas">FAS</a>, an independent program <li> Powered by a wavetable </ul></span>
	<li> Stereophonic / Monaural
	<li> Polyphonic
		<span><ul><li> Automatically detected from the GPU capabilities <li> 16 notes minimum <li> 704 notes with a GeForce GTX 970 GPU</ul></span>
	<li> Multitimbral
	<li> Spectral recording with mixing and PNG export
	<li> Adjustable audio output channel per slices
		<span><ul><li> Multiple audio channels are only supported with <a rel="tag" href="#fas">FAS</a></ul></span>
	<li> Shader inputs, webcam, textures, audio files, canvas
	<li> WebGL 2.0 and GLSL 3.0 support when compatibility is detected
	<li> MIDI Enabled
		<span><ul><li> Only with WebMIDI API enabled browsers (Google Chrome) <li> Hot plugging of MIDI devices is supported</ul></span>
	<li> Collaborative app.
		<span><ul><li> MIDI and shader inputs are not synchronized between users</ul></span>
  <li> Feedback support
	<li> Live coding/JIT compilation of shader code
	<li> Global and per sessions settings auto save/load
	<li> No authentifications (sessions based)
	<li> Per-sessions discussion system</ul></span>
<br>
<a id="subsec1_3"></a><span style="font-size: 120%;"><strong>1.3. System requirements</strong></span><br><br>
Fragment is a special kind of additive synthesizer which require a moderate deal of processing power in order to work properly, a medium-end GPU and CPU should work fine.
<br>
<a id="subsubsec1_3_1"></a><br><br><strong>1.3.1. Browser</strong><br><br>
Fragment require a browser with full support for ECMAScript 5, CSS3, WebAudio and WebGL.<br><br>Well-tested and compatible browsers include Firefox 51.x and Chrome 55.x but Fragment may work with previous version of those browsers as well.<br><br>It is known to work on recent version of Safari and Opera as well.<br><br>Chrome or Chromium browser is recommended.<br><br>Fragment support the WebGL 2 API which improve performances, possibilities and enable advanced features in the fragment shader due to GLSL 3.0 usage.
<br>
<a id="subsubsec1_3_2"></a><br><br><strong>1.3.2. CPU</strong><br><br>
Fragment may be quite hungry in term of computing resources, a dual core with high clock speed is recommended, a CPU with more cores can be useful if you just want to use the browser for audio output.<br><br>Several methods are provided to synthesize sounds, each with performances pros and cons:
<span><ul>
	<li> <a rel="tag" href="#fas">FAS</a> (<strong>recommended method</strong>): <span><ul><li> Fastest <li> Multiple output support with soundcard choice <li> Many audio settings <li> Can run on a dedicated computer such as a Raspberry PI <li> Dedicated program which receive Fragment data over the network <li> Enhanced noise modeling with band-limited noise <li> Granular synthesis capability (soon)</ul></span>
	<li> WebAudio oscillators: <span><ul><li> Fastest with Chrome <li> May not work with Firefox if the canvas is too high vertically <li> Require a fast CPU <li> Integrated global "release" envelope</ul></span>
	<li> Wavetable <strong>not recommended</strong>: <span><ul><li> Most compatible browser method <li> Will produce crackles</ul></span></ul></span>
<a id="subsubsec1_3_3"></a><br><br><strong>1.3.3. GPU</strong><br><br>
Fragment was developed and tested with a NVIDIA GeForce GTX 970 GPU, a powerful GPU may be required if:
<span><ul>
	<li> you want higher score resolution
	<li> you want to do visuals alongside audio
	<li> you are doing complex things/use many inputs in your shader
	<li> you want greater polyphonic/harmonics/partials capabilities</ul></span>
<a id="sec2"></a><br><br><span style="font-size: 120%;"><span style="font-size: 120%;"><strong>2. Concept</strong></span></span><br><br>
Fragment basically capture 1 pixel wide slices of a canvas at the display refresh rate and translate RGBA pixels value to notes, the notes are then interpreted and played by one of the synthesis tool.<br><br>The content of the canvas is produced on the GPU by a collaborative GLSL script, the GPU make it extremely fast and easy to do any kinds of pixels manipulations.<br><br>There is many features in Fragment which allow any creative minds to produce complex sounds in different ways and even with external tools, i suggest all the readers to look at great softwares like the <a href="https://www.iannix.org">IanniX sequencer</a> and to use it with Fragment using the MIDI capabilities.<br><br>While Fragment may seem overwhelming at first, the only thing that is required to produce sounds with it is to know how to generate the visuals, the visuals can be drawn directly over the canvas with a canvas input, produced directly by the GLSL code, come from images, sound files, webcam etc.<br><br>The goal of this section is to clarify the inner working of Fragment.<br><br><br>
<a id="subsec2_1"></a><span style="font-size: 120%;"><strong>2.1. Additive synthesis</strong></span><br><br>
Fragment is first and foremost a powerful additive synthesizer which make an extended use of additive synthesis.<br><br>Additive synthesis is a sound synthesis technique that create timbres by adding sine waves together.<br><br>Adding sine waves produce a timbre, the timbre quality is mainly defined by its harmonic content and the dynamic characteristics of the harmonic content.<br><br>The concept of additive synthesis is centuries old, it has first been used by pipe organs.<br><br>Fragment can theoretically produce any timbres with precise accuracy.<br><br>The only limit to the amount of sine waves that can be added by Fragment is the limit of the available processing power.<br><br>For example, on a Raspberry PI 3 (1.2GHz 64-bit quad-core ARMv8 CPU) ~700 oscillators can be played simultaneously using two cores, matching the capability of the ANS synthesizer.<br><br>Actually, there is a also a hard limit which is that the frequency capture of slices cannot go beyond the refresh rate of your monitor (and this also depend on the browser implementation, commonly 60 FPS which mean ~16ms time granularity), this could however be bypassed by switching to a different monitor.<br><br>Fragment can also do other types of synthesis like granular synthesis.<br><br><br>
<a id="score"></a>
<a id="subsec2_2"></a><span style="font-size: 120%;"><strong>2.2. The graphical score</strong></span><br><br>
Fragment graphical score represent the sound spectrum which is generated by the GPU from a fragment program.<br><br>The fragment program (also known as a fragment shader) is executed by the GPU and compute the color and other attributes of each "fragment" - a technical term which mean a single pixel.<br><br>The graphical score represent a kind of sonic canvas where the X axis represent time and the Y axis represent frequencies, you "paint" the graphical score by writing a fragment program which will be executed for each pixels of the graphical score.<br><br>What you hear in Fragment is determined by the position of "slices" which are added on the graphical score, slices are vertical bits of the graphical score which are merged together and produce an audible result.<br><br>The content of slices is captured at the rate of the display refresh rate which conventionally should be 60fps most of the time which mean a time granularity of at best ~16ms.<br><br>The frequency mapping of the graphical score is fixed by a logarithmic formula, altough the formula cannot be changed right now, some parameters are available in the settings dialog to fine tune the frequency map.<br><br>The frequency mapping is defined by the formula:
<p style="text-align: center;"><img src="png/fJCBv8mOl-C9YgjNVFHoP3ypseu8.png" width="106" height="25" style="vertical-align: -0px"></p>
Where:
<span><ul>
	<li> <strong>a</strong> is is the starting frequency
	<li> <strong>y</strong> the vertical position
	<li> <strong>n</strong> the number of oscillators (which is the height of the canvas)
	<li> <strong>o</strong> the octave count</ul></span>
	
<a id="sec3"></a><br><br><span style="font-size: 120%;"><span style="font-size: 120%;"><strong>3. Sessions</strong></span></span><br><br>
Fragment sessions are isolated spaces which are open to all peoples who has access to the session name, they can be joined by going to the Fragment <a href="https://www.fsynth.com">homepage</a> or by typing the session name directly into the address bar as demonstrated below.<br><br>You can join any sessions directly from your browser address bar by replacing "yoursessionname" for the URL shown below by the session name you want to join or create, session names are limited to a maximum of 100 characters and cannot use the "$" character:<br><br><div style="text-align: center; color: inherit; font-size: inherit;"><p>https://www.fsynth.com/app/<strong>yoursessionname</strong></p></div>
Fragment store sessions content and settings on a server which mean that any of the synchronizable actions in the session such as the code editor content, canvas settings, slices and <a rel="tag" href="#uniformsdialog">uniform inputs</a> are automatically saved <strong>if</strong> Fragment is connected.<br><br>Fragment synchronize the code editor content, slices, canvas settings and <a rel="tag" href="#uniformsdialog">uniform inputs</a> across all the users in the session in real-time which mean that you can jam with your friends if you share the session URL.<br><br>Note that MIDI note messages are not synchronized between users due to technical constraints but you can still add <a rel="tag" href="#uniformsdialog">uniform inputs</a> and assign MIDI devices to control them, their values are synchronized between users.<br><br>Some settings are saved locally on your browser, some of them are global (like the username and settings related to the editor) and some of them are saved per sessions such as the MIDI settings, gain and inputs.<br><br>Fragment is respectful of the user and does not store any informations related to the user outside the boundary defined by the application focus.<br><br><br>
<a id="subsec3_1"></a><span style="font-size: 120%;"><strong>3.1. Homepage and sessions history</strong></span><br><br>
The Fragment <a href="https://www.fsynth.com">homepage</a> can be used to retrieve the various sessions that you joined, a session list will be shown once you joined at least one session.
<a href="images/homepage_sessions.png"><div style="text-align: center; color: inherit; font-size: inherit;"><p><img src="images/homepage_sessions.png" width="600"></p></div></a>
You can join a session from the list by clicking on it and by clicking on the door icon.<br><br>You can remove a session from the list by clicking on it and by clicking on the trash icon.<br><br>You can also clear the sessions history by clicking on the corresponding button, it will not delete the session content, just your settings for that session and the session will removed from the list, a deleted session can be joined back from the homepage form or by the browser address bar if you know its name.<br><br><a id="fas"></a>
<a id="sec4"></a><br><br><span style="font-size: 120%;"><span style="font-size: 120%;"><strong>4. FAS</strong></span></span><br><br>
FAS (Fragment Audio Server) is the Fragment synthesis engine as a server, it is an external independent program written with the C language for very fast real-time audio synthesis.<br><br>It is recommended to use Fragment with FAS enabled.<br><br>The advantage of using FAS is that it provide the best audio performances along with audio devices choice, multiple audio output per slices, sample rate choice, granular synthesis method, realtime scheduling under Linux and more...<br><br>Fragment communicate with FAS by sending data through the network when the FAS option is enabled, FAS can run on any machines independently of the Fragment application, it gather the pixels data from Fragment in real-time, compute things and deliver the audio through the selected audio device.<br><br>FAS can be downloaded on the Fragment <a href="https://www.fsynth.com">homepage</a>, it can also be compiled from sources on <a href="https://github.com/grz0zrg/fas">GitHub</a>.<br><br>FAS is provided as an executable for the following platforms at the moment:
<span><ul>
	<li> Windows x86/x64 32/64 bits
	<li> Linux x86/x64 32/64 bits
	<li> Raspberry PI (~700 oscillators can play at the same time under optimized system)</ul></span>
Here is a list of the program arguments which FAS support (along with the default settings if not provided):
<span><ul>
	<li> --h
	<span><ul>
		<li> show the program arguments</ul></span>
  <li> --i
  <span><ul>
  	<li> print audio device informations</ul></span>
	<li> --device -1
	<span><ul>
		<li> the id of the audio device to use (running FAS without arguments once will print the devices found along with their id and informations)</ul></span>
	<li> --iface 127.0.0.1
	<span><ul>
		<li> the address on which to listen</ul></span>
	<li> --port 3003
	<span><ul>
		<li> the network port on which to listen</ul></span>
	<li> --output_channels 2
	<span><ul>
		<li> the number of output channels, the value must be an even number</ul></span>
	<li> --alsa_realtime_scheduling 0
	<span><ul>
		<li> enable/disabled ALSA realtime scheduling, a Linux only parameter</ul></span>
	<li> --sample_rate 44100
	<span><ul>
		<li> can be any sample rate supported by the selected audio device</ul></span>
	<li> --frames 512
	<span><ul>
		<li> the audio buffer size, this have an effect on audio latency and CPU usage</ul></span>
	<li> --wavetable_size 8192
	<span><ul>
		<li> the wavetable size, the default value should be enough for most uses</ul></span>
	<li> --fps 60
	<span><ul>
		<li> this setting is provided in case Fragment does not capture slices at 60 fps, on most setup Fragment try to capture slices at 60 fps</ul></span>
	<li> --ssl 0
		<span><ul>
			<li> this is provided to use FAS over SSL (not recommended at all!)</ul></span>
	<li> --max_height 4096
		<span><ul>
			<li> if you set the score height above 4096 pixels in Fragment, keep in mind that you must increase this!</ul></span>
	<li> --deflate 0
		<span><ul>
			<li> a value of 1 will enable deflate compressed packets (not recommended)</ul></span>
	<li> --rx_buffer_size 4096
		<span><ul>
			<li> FAS will fragment packets which are bigger than the default value</ul></span>
	<li> --frames_queue_size 7
		<span><ul>
			<li> this is the length of the maximum number of frames waiting in the queue
			<li> this is an important parameter, if you increase this too much the audio will be delayed</ul></span>
	<li> --commands_queue_size 16
		<span><ul>
			<li> this is the same as frames_queue_size except for commands (gain changes etc.)
			<li> should be a power of 2 and positive integer</ul></span></ul></span>
Once launched, you can stop the FAS server by pressing any keys.
<br>
<a id="sec5"></a><br><br><span style="font-size: 120%;"><span style="font-size: 120%;"><strong>5. The user interface</strong></span></span><br><br>
<a href="images/ui_help.png"><div style="text-align: center; color: inherit; font-size: inherit;"><p><img src="images/ui_help.png" width="600"></p></div></a>
<a href="images/ui_help.png"><div style="text-align: center; color: inherit; font-size: inherit;"><p>Click to view the full image</p></div></a>
Fragment user interface is quite easy to use once you figure out its layout.<br><br>It is composed of a few parts with very specific roles, below is a list of parts with detailed informations of their functions and supported actions.<br><br><br>
<a id="subsec5_1"></a><span style="font-size: 120%;"><strong>5.1. Dialogs</strong></span><br><br>
There is many dialogs in Fragment, they are composed of a title bar with some actions, the dialog content and sometimes a status bar, dialogs hover above the rest of the application, you can move them around and close them, some are also resizable, minimizable and detachable in a separate window.<br><br>To resize dialogs, place the mouse cursor on the bottom right corner of the dialog, click and drag to the desired size.<br><br><a href="gif/dialog_resize.gif"><div style="text-align: center; color: inherit; font-size: inherit;"><p><img src="gif/dialog_resize.gif" width="600"></p></div></a>
A minimized dialog will take less space on the screen by only displaying the title bar.<br><br>Here is a list of dialog actions (in the order by which they appear from left to right):
<a href="images/dialog_actions.png"><div style="text-align: center; color: inherit; font-size: inherit;"><p><img src="images/dialog_actions.png" width="93"></p></div></a>
<span><ul>
	<li> close the dialog
	<li> minimize/maximize
	<li> detach the dialog in a new window
	<li> help (direct link to the documentation section)</ul></span>
<br>
<a id="subsec5_2"></a><span style="font-size: 120%;"><strong>5.2. The information bar</strong></span><br><br>
The information bar at the top convey minor and major informations such as (in order from left to right):
<span><ul>
	<li> connectivity status
	<span><ul>
		<li> a red indicator signal that the connection to this service failed
		<li> the service name can be found by hovering the cursor on the icon</ul></span>
	<li> your online name
	<span><ul>
		<li> you can change your username by clicking on it</ul></span>
	<li> various informations which can be enabled or disabled in the settings dialog such as:
	<span><ul>
		<li> the current frequency under the mouse cursor
		<li> the actual number of simultaneous MIDI notes
		<li> the actual number of oscillators playing</ul></span>
	<li> the playback time at the center
	<li> a gain controller (master volume)</ul></span><br><br><a id="subsec5_3"></a><span style="font-size: 120%;"><strong>5.3. The graphical score</strong></span><br><br>
You can slice the graphical score by right-clicking on it and by clicking on the + icon, this will add a vertical bar which will capture that part of the canvas.
<a href="gif/add_slices.gif"><div style="text-align: center; color: inherit; font-size: inherit;"><p><img src="gif/add_slices.gif" width="294"></p></div></a>
You are free to add any number of slices, adding many slices may have an impact on performances.
<br>
<a id="subsubsec5_3_1"></a><br><br><strong>5.3.1. Slice</strong><br><br>
Slices are an important part of Fragment, there will be no sounds if you don't add at least one slice.<br><br>The purpose of slices is to capture the pixels of vertical parts of the canvas which will be fed to the audio synthesis engine, they are like turntable needles, they can be dragged around in real-time by the mouse or by a MIDI controller, you can use programs like <a href="https://www.iannix.org">IanniX</a> to move them following certain kind of patterns.<br><br>Slices can be moved by dragging them on the X axis, to do so, maintain the left mouse button on a slice and move the mouse cursor around on the horizontal axis.
<a href="gif/dragging_slices.gif"><div style="text-align: center; color: inherit; font-size: inherit;"><p><img src="gif/dragging_slices.gif" width="600"></p></div></a>
Double-clicking on a slice open its settings dialog directly:
<a href="images/slice_settings.png"><div style="text-align: center; color: inherit; font-size: inherit;"><p><img src="images/slice_settings.png" width="336"></p></div></a>
The following actions are possible by right-clicking on a slice:
<span><ul>
	<li> mute/unmute
	<span><ul><li> the synthesis engine will ignore a muted slice</ul></span>
	<li> open the slice settings which posses the following controllers:
	<span><ul>
		<li> X Offset: the slice horizontal position which can be controlled by a MIDI controller
		<li> Y Shift: pitch the slice audio up or down (there is no visual representation of this)
		<li> Increment per frame: This allow the slice to move left or right automatically, this is the increment value per frames
		<li> <a rel="tag" href="#fas">FAS</a> Output channel: the l/r output channel which will be used by FAS for that slice</ul></span>
	<li> deletion</ul></span>
Here is how you can mute a slice:
<a href="gif/mute_slice.gif"><div style="text-align: center; color: inherit; font-size: inherit;"><p><img src="gif/mute_slice.gif" width="600"></p></div></a>
Here is how you can delete a slice:
<a href="gif/remove_slices.gif"><div style="text-align: center; color: inherit; font-size: inherit;"><p><img src="gif/remove_slices.gif" width="600"></p></div></a><br><br><a id="subsec5_4"></a><span style="font-size: 120%;"><strong>5.4. The toolbar</strong></span><br><br>
<a href="images/toolbar.png"><div style="text-align: center; color: inherit; font-size: inherit;"><p><img src="images/toolbar.png" width="574"></p></div></a>
<br>
The toolbar is a collection of tools and settings which are grouped by sections, here is a detailed list of the toolbar items (in order from left to right):
<span><ul>
	<li> help
	<li> social
	<span><ul>
		<li> session live chat
		<li> direct link to the community board</ul></span>
	<li> settings
  <span><ul>
  	<li> <a rel="tag" href="#globalsettingsdialog">session and global settings</a>
  	<li> <a rel="tag" href="#midisettingsdialog">MIDI settings</a></ul></span>
  <li> transport
  <span><ul>
  	<li> reset playback time to 0
  	<li> play/pause
  	<li> <a rel="tag" href="#record">recording dialog</a>
  	<li> <a rel="tag" href="#fas">FAS enable/disable</a></ul></span>
  <li> helpers
  <span><ul>
  	<li> <a href="https://www.shadertoy.com">ShaderToy</a> converter
  	<li> canvas axis details which appear when the canvas is hovered by the cursor
  	<li> <a rel="tag" href="#outline">GLSL outline dialog</a>
  	<li> clone the code editor in a separate window</ul></span>
	<li> fragment inputs
	<span><ul>
		<li> <a rel="tag" href="#uniformsdialog">uniforms</a>
		<li> <a rel="tag" href="#finputs">GLSL inputs import</a></ul></span></ul></span><br><br><a id="finputs"></a>
<a id="subsec5_5"></a><span style="font-size: 120%;"><strong>5.5. The fragment inputs</strong></span><br><br>
Fragment inputs are complex inputs which can be used in the fragment program as a 2D texture.<br><br>The fragment inputs panel is a complete list of all the added inputs, each of them appear as a thumbnail near the <strong>add complex inputs button</strong>, nothing will be shown if no complex inputs were added.<br><br>All complex inputs can be used as 2D textures (texture2d) within the fragment program, they are defined as <strong>iInputN</strong> where N is the id of the input starting from 0.<br><br>You can find the input id by hovering over the thumbnail or in the title of the complex input settings dialog.<br><br><a href="gif/input_reorder.gif"><div style="text-align: center; color: inherit; font-size: inherit;"><p><img src="gif/input_reorder.gif" width="294"></p></div></a>
<div style="text-align: center; color: inherit; font-size: inherit;"><p>Complex inputs can be ordered in real-time by drag &amp; drop.</p></div><br><br>To open the complex input import dialog, click on the "add complex inputs" button, a new dialog will appear with three sections:<br><br><div style="text-align: center; color: inherit; font-size: inherit;"><p><img src="images/import.png" width="394"></p></div>
<span><ul>
	<li> Audio import settings: This determine how audio files will be analyzed when imported
	<span><ul>
		<li> Window type: The windowing function to use
		<li> Window length: Analysis window length (tradeoff between time and frequency resolution)
		<li> Overlap
		<li> BPM
		<li> PPB: Pixel Per Beat
		<li> Height: A value of 0 will automatically create an input with the height equal to the score height
		<li> Min. freq.: A value of 0 will automatically assign the score min. frequency
		<li> Max. freq.: A value of 0 will automatically assign a max. frequency related to the score settings</ul></span>
	<li> Import toolbar
	<span><ul>
		<li> Image: This will open a file selection window to import images
		<li> Audio: This will open a file selection window to import audio files
		<li> Webcam
		<li> Canvas</ul></span>
	<li> Dropzone: You can use this to import many files at the same time</ul></span>
	
Once added, by left clicking on a complex input thumbnail the following actions appear:
<span><ul>
	<li> complex input settings dialog
	<li> delete
	<li> export as PNG (only for images, open a new window)</ul></span><br><br>By rick-clicking on the input thumbnail of a canvas input, the canvas input will be selected and a <a rel="tag" href="#canvas">"paint tools" dialog</a> will appear<br><br><a href="gif/fragment_input.gif"><div style="text-align: center; color: inherit; font-size: inherit;"><p><img src="gif/fragment_input.gif" width="600"></p></div></a>
<div style="text-align: center; color: inherit; font-size: inherit;"><p>The complex input settings dialog</p></div>
<br>
The complex input settings dialog have several options:
<span><ul>
	<li> filter
	<span><ul>
		<li> nearest: no interpolation
		<li> linear: linear interpolation</ul></span>
	<li> Wrap S
	<span><ul>
		<li> clamp: stop horizontally when outside the (0,0) to (1,1) range
		<li> repeat: repeat horizontally when outside the (0,0) to (1,1) range
		<li> mirrored repeat: same as repeat but mirrored</ul></span>
	<li> Wrap T
	<span><ul>
		<li> clamp: stop vertically when outside the (0,0) to (1,1) range
		<li> repeat: repeat vertically when outside the (0,0) to (1,1) range
		<li> mirrored repeat: same as repeat but mirrored</ul></span>
	<li> VFlip: flip the texture vertically</ul></span>
<strong>Note</strong>: The "repeat" and "mirrored" Wrap S/T option will be unavailable if your browser does not support the WebGL 2 API, it is only available by adding images with power-of-2 dimensions (128x64, 256x256 etc.) or by using a browser with WebGL 2 support.<br><br><br>
<a id="canvas"></a>
<a id="subsec5_6"></a><span style="font-size: 120%;"><strong>5.6. The canvas input</strong></span><br><br>
The canvas input is a powerful feature which allow to draw on a canvas with brushes, the canvas is usable within the fragment shader as a texture which is updated as you draw on it.<br><br>When you right click on the canvas input thumbnail, the canvas input will be selected and appear with green borders, the canvas content will appear in front of the graphical score and a "paint tools" dialog will open.<br><br>You can directly draw on the graphical score when a canvas input is selected but you cannot move or add slices anymore, you must unselect the selected canvas input before.<br><br>A right click on a selected canvas input thumbnail will unselect it.<br><br>Brushes can be added by adding complex inputs images from the <a rel="tag" href="#finputs">import inputs dialog</a>.<br><br>Brushes can be selected by clicking on the corresponding brush thumbnail.<br><br>Any actions affecting brushes will display an overlay helper for some seconds to help you visualize the changes.<br><br>To draw on the canvas input, you must first select a brush in the "paint tools" dialog, Fragment is bundled with 970 high-quality brushes.<br><br><div style="text-align: center; color: inherit; font-size: inherit;"><p><img src="images/paint_toolbox.png" width="410"></p></div>
<div style="text-align: center; color: inherit; font-size: inherit;"><p>The "paint tools" dialog has three parts, a toolbar, brush settings and the brushes list.</p></div>
The toolbar actions:
<span><ul>
	<li> Clear the canvas
	<li> Lock the horizontal axis when drawing
	<li> Lock the vertical axis when drawing
	<li> Randomize
	<span><ul>
		<li> Randomize brush scale, opacity and angle when drawing</ul></span>
	<li> Compositing method selection
	<span><ul>
		<li> Compositing methods details can be found <a href="https://developer.mozilla.org/fr/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation">here</a></ul></span>
</ul></span>
The sliders:
<span><ul>
	<li> Brush width scale
	<li> Brush height scale
	<li> Brush opacity
	<li> Brush angle
	<li> Brush spacing delay (milliseconds)
</ul></span><br><br><a id="subsec5_7"></a><span style="font-size: 120%;"><strong>5.7. The code editor</strong></span><br><br>
The code editor is one of the most important Fragment since it allow the user to generate the visuals which are fed to the audio synthesis engine.<br><br><a href="https://www.khronos.org/files/opengles_shading_language.pdf">GLSL</a> code is what you type in the code editor to generate the visuals.<br><br>The fragment program is compiled as you type, if the compilation fail, the code editor will notice you with a floating message and with a red message at the lines that cause the compilation to fail, all of that without interrupting sounds/visuals output, this enable powerful live coding.<br><br><a href="gif/glsl_inline_report.gif"><div style="text-align: center; color: inherit; font-size: inherit;"><p><img src="gif/glsl_inline_report.gif" width="600"></p></div></a>
<br>
The changes that you make in the code editor are automatically saved per named sessions, changes are also synchronized in real-time between all the users of the session you are currently in, this is the collaborative nature of Fragment.<br><br>The code editor is powered by the CodeMirror library, it feature many neat things such as:
<span><ul>
	<li> GLSL syntax highlighting
	<li> highlight matches
	<li> brackets/parentheses opening/end highlights
	<li> fullscreen editor by pressing F11
	<li> integrated compilation errors/messages (does not interrupt sounds/visuals)
	<li> line numbers
	<li> many bundled editor themes</ul></span>
Some of the code editor features can be enabled/disabled in the <a rel="tag" href="#globalsettingsdialog">global settings dialog</a>.<br><br>If you experience audio stuttering as you type, it is recommended to detach the code editor off the main window, due to the complexity of the web and the complexity of the Fragment application, many things are not as optimal as they should be, you may hear audio crackles due to browser reflow.<br><br><br>
<a id="subsec5_8"></a><span style="font-size: 120%;"><strong>5.8. MIDI learn functionality</strong></span><br><br>
MIDI learn is a neat feature of Fragment which enable any MIDI learn enabled widget to be controlled by a MIDI controller.
<a href="images/midi_learn.png"><div style="text-align: center; color: inherit; font-size: inherit;"><p><img src="images/midi_learn.png" width="104"></p></div></a>
<div style="text-align: center; color: inherit; font-size: inherit;"><p>The red square indicate MIDI learn functionality support for this widget</p></div>
The red square appearing on an UI interface widget indicate that the MIDI learn functionality is supported for the widget, it only appear on WebMIDI enabled browsers such as Chrome and Opera and on widgets which are allowed to be controlled by MIDI.<br><br>By left clicking on the red square, it turn green and any inputs from the <a rel="tag" href="#midisettingsdialog">enabled MIDI devices</a> will be captured by the widget.<br><br>Once the MIDI input is captured, the green square become red again (which is a locked state) and the MIDI control will be assigned to the widget.<br><br>It is possible to reset the MIDI control assigned to the widget by clicking on the red square and clicking again on the green square aka double clicking.<br><br><br>
<a id="globalsettingsdialog"></a>
<a id="subsec5_9"></a><span style="font-size: 120%;"><strong>5.9. The session/global settings dialog</strong></span><br><br>
<a href="images/settings.png"><div style="text-align: center; color: inherit; font-size: inherit;"><p><img src="images/settings.png" width="347"></p></div></a>
<br>
The session &amp; global settings dialog content (in order from top to bottom):
<span><ul>
	<li> Score width
	<span><ul>
		<li> The score width in pixels units</ul></span>
	<li> Score height
	<span><ul>
		<li> The score height in pixels units
		<li> Higher height = better resolution in term of frequencies</ul></span>
	<li> Score base frequency
	<span><ul>
		<li> Determine the base frequency in hertz units</ul></span>
	<li> Score octave range
	<span><ul>
		<li> Control the range of frequencies</ul></span>
	<li> Osc. fadeout
	<span><ul>
		<li> WebAudio fadeout time (like "release" parameter in other synts, WebAudio oscillators only)</ul></span>
	<li> Polyphony
	<span><ul>
		<li> Maximum polyphony</ul></span>
	<li> Show globalTime
	<span><ul>
		<li> Hide/Show the globalTime in the informations bar</ul></span>
	<li> Show osc. infos
	<span><ul>
		<li> Hide/Show the number of oscillators playing simultaneously in the informations bar</ul></span>
	<li> Show poly. infos
	<span><ul>
		<li> Hide/Show the polyphony infos for per output channels in the informations bar</ul></span>
	<li> Show slices bar
	<span><ul>
		<li> Hide/Show slices vertical bar</ul></span>
	<li> Show line numbers
	<span><ul>
		<li> Hide/Show the line number in the code editor</ul></span>
	<li> Advanced scrollbar
	<span><ul>
		<li> Enable/disable a better looking scrollbar for the code editor</ul></span>
	<li> Highlight matches
	<span><ul>
		<li> Enable/disable matches highlight in the code editor (when something is selected)</ul></span>
	<li> Show slices
	<span><ul>
		<li> Hide/Show slices, can be useful for visuals, this settings is not saved</ul></span>
	<li> Monophonic
	<span><ul>
		<li> Enable/disable monophonic mode
		<li> If monophonic is enabled, only the alpha value is used by the synthesis engine, the full RGB output can then be used for visuals</ul></span>
	<li> Wavetable
	<span><ul>
		<li> Enable/disable the synthesis engine wavetable feature (uglier audio output but may be the less CPU intensive mode)</ul></span>
	<li> Feedback
	<span><ul>
		<li> Enable/disable the availability of the previous frame in the fragment shader (aka feedback), this is useful for complex effects, may be CPU/GPU intensive</ul></span>
	<li> Editor theme
	<span><ul>
		<li> A list of themes for the code editor</ul></span>
	<li> FAS address
	<span><ul>
		<li> The location of <a rel="tag" href="#fas">FAS (Fragment Audio Server)</a> on the network</ul></span></ul></span><br><br><a id="midisettingsdialog"></a>
<a id="subsec5_10"></a><span style="font-size: 120%;"><strong>5.10. MIDI settings dialog</strong></span><br><br>
<a href="images/midi_settings.png"><div style="text-align: center; color: inherit; font-size: inherit;"><p><img src="images/midi_settings.png" width="325"></p></div></a>
<br>
The MIDI settings dialog show all the MIDI input devices found at this time, by default there is no MIDI input devices enabled, you can enable MIDI devices by checking the checkbox below the MIDI device name.<br><br>Once enabled, Fragment will receive any MIDI messages from that device.<br><br>Fragment support hot plugging of MIDI devices, any MIDI devices which are plugged or unplugged while Fragment is running will be added or removed in the MIDI settings dialog.<br><br>Fragment keep track of your MIDI settings choice for particual devices per sessions, this mean that if a MIDI device is enabled, when you quit Fragment or that the MIDI device is unplugged and you launch again Fragment and that the MIDI device is plugged in, Fragment will enable it automatically.<br><br><br>
<a id="record"></a>
<a id="subsec5_11"></a><span style="font-size: 120%;"><strong>5.11. Recording dialog</strong></span><br><br>
The recording dialog allow to continuously record the slices output from all channels into one score that you can export to PNG by clicking on the save icon.<br><br>This tool can become handy if you want to export your work and import it into an external tool or within Fragment again by clicking on the [+] icon.<br><br>Can also serve for spectral analysis.<br><br>The recording dialog support mixing functions, for example by clicking on the + icon, the recording will be additive which mean that slices content will be drawn on the previous content without erasing it, a list of all the toolbar actions can be found below.<br><br>The recording canvas width is linked to the score width.<br><br>Recording toolbar buttons (in order from left to right):
<span><ul>
	<li> Reset &amp; clear
	<li> Additive mode
	<li> Substractive mode
	<li> Multiply mode
	<li> Add the recorded image as a new GLSL input
	<li> Export as PNG (open a new dialog)</ul></span><br><br><br>
<a id="outline"></a>
<a id="subsec5_12"></a><span style="font-size: 120%;"><strong>5.12. Outline dialog</strong></span><br><br>
The outline dialog display a list of GLSL functions, declarations and "defines" defined in your shader code, you can click on any elements to jump at it in the code editor, this is very useful with long shader code.<br><br><br>
<a id="subsec5_13"></a><span style="font-size: 120%;"><strong>5.13. Session chat dialog</strong></span><br><br>
<a href="images/session_chat.png"><div style="text-align: center; color: inherit; font-size: inherit;"><p><img src="images/session_chat.png" width="600"></p></div></a>
The session chat dialog allow discussions with all users in the current session.<br><br>It is a simple but effective chatbox that you can resize, move around or detach. it has three parts:
<span><ul>
	<li> messages list
	<li> users list
	<li> input</ul></span>
The user list indicate yourself with a green color.<br><br>You can send a message to all users in the session by clicking on the input then typing your message and pressing ENTER.<br><br>Each messages received has a timestamp assigned that you can read by hovering your mouse cursor on the message.<br><br><br>
<a id="uniformsdialog"></a>
<a id="subsec5_14"></a><span style="font-size: 120%;"><strong>5.14. Uniforms dialog</strong></span><br><br>
The uniforms dialog is a very powerful functionality.<br><br>It enable you to define fragment program uniforms (aka variables) which are synced with all users in the session and are controllable by any MIDI input devices enabled.<br><br>All the uniforms added will be shown in the uniforms dialog and will be defined automatically in the fragment program, you can then just use the symbol name in the code editor.<br><br>You can add the following scalar uniforms types:
<span><ul>
	<li> bool
	<li> int
	<li> float</ul></span>
If count is higher than 1, Fragment will add the scalar uniforms as an array.<br><br>	
You can also add vector uniforms of the following types (note: the components field determine the number of components for the following uniform type):
<span><ul>
	<li> bvec2
	<li> bvec3
	<li> bvec4
	<li> ivec2
	<li> ivec3
	<li> ivec4
	<li> vec2
	<li> vec3
	<li> vec4</ul></span>
If count is higher than 1, Fragment will add the vector uniforms as an array.
<br>
<a id="sec6"></a><br><br><span style="font-size: 120%;"><span style="font-size: 120%;"><strong>6. How to produce sounds by programming your GPU</strong></span></span><br><br>
Fragment usage of the GPU is restricted to a single fragment program which will be executed by the GPU for each pixels of the graphical score.<br><br>The fragment program is written in GLSL (OpenGL Shading Language) which has a syntax quite similar to the C language but is much simpler to learn.<br><br>You can do anything from ray-traced 3D to drawing simple lines and define their behaviors with Fragment, the only requirement is high school mathematics.<br><br>Fragment support GLSL 3.0 version automatically if it detect support for the WebGL 2.0 API (which is recommended), GLSL 3.0 allow to use dynamical indexes with arrays among many other things, it also allow to use shortcuts such as <span style="display: inline; color: rgb(0,130,0)">fragColor</span> instead of gl_FragColor and <span style="display: inline; color: rgb(0,130,0)">texture</span> instead of texture2D.<br><br>This documentation focus on the audio synthesis aspect of Fragment as there is already plenty resources covering the creation of stunning visuals with GLSL programs on the web.<br><br>There is also many applications that let you create stunning visuals in your browser by the same method, one of the most popular one and compatible with Fragment (by using the convert ShaderToy button of the toolbar) is <a href="https://www.shadertoy.com/">ShaderToy</a>, this program let you build visuals and audio at the same time, just like Fragment but with a more conventional approach to audio synthesis.<br><br><br>
<a id="subsec6_1"></a><span style="font-size: 120%;"><strong>6.1. OpenGL Shading Language</strong></span><br><br><br><br>The Khronos Group (authors of the language specification) released several reference cards of the GLSL specification, the reference cards are compact reference of the full language specification which can be used in conjunctions with code samples to learn the OpenGL Shading Language quickly.<br><br>Since there is plenty of resources to learn the OpenGL Shading Language, the documentation provided in this section will only provide the official reference cards which are enough to learn from to understand all the GLSL code that will follow.<br><br>As Fragment can use WebGL 2.0 if your browser has support for it, the reference cards for both WebGL 1.0 GLSL and WebGL 2.0 GLSL (more functionalities) is provided, keep in mind that if Fragment run fine with your browser, you can safely use the WebGL 1.0 GLSL reference card as a starting point:
<span><ul>
	<li> WebGL 1.0 OpenGL Shading Language
	<span><ul>
		<li> <a href="pdf/webgl1_glsl_1.pdf">Page 1 PDF</a>
		<li> <a href="pdf/webgl1_glsl_2.pdf">Page 2 PDF</a></ul></span></ul></span>
<span><ul>
	<li> WebGL 2.0 OpenGL Shading Language
	<span><ul>
		<li> <a href="pdf/webgl2_glsl_1.pdf">Page 1 PDF</a>
		<li> <a href="pdf/webgl2_glsl_2.pdf">Page 2 PDF</a>
		<li> <a href="pdf/webgl2_glsl_3.pdf">Page 3 PDF</a></ul></span>
</ul></span>
<br>
Here is a simple example of GLSL code that Fragment accept which just set all pixels to black:
<pre style="color: inherit; font-size: inherit; background-color: rgb(230,235,220); width: 600px;">
  <span style="display: inline; color: rgb(10,0,130)">void</span> main () {
    <span style="display: inline; color: rgb(0,100,0)">gl_FragColor</span> <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(10,0,130)">vec4</span>(<span style="display: inline; color: rgb(130,0,0)">0.</span>, <span style="display: inline; color: rgb(130,0,0)">0.</span>, <span style="display: inline; color: rgb(130,0,0)">0.</span>, <span style="display: inline; color: rgb(130,0,0)">0.</span>);
  }
</pre>
In the subsequent GLSL code, <span style="display: inline; color: rgb(10,0,130)">blue words</span> are GLSL keywords, <span style="display: inline; color: rgb(130,0,0)">red</span> are float values and <span style="display: inline; color: rgb(0,130,0)">green words</span> are pre-defined specific definitions or functions.<br><br><br>
<a id="subsec6_2"></a><span style="font-size: 120%;"><strong>6.2. Pre-defined uniforms</strong></span><br><br>
Fragment has many pre-defined uniform variables which can be used to animate/modulate things, here are all the pre-defined uniforms along with their type that can be used directly in your code:
<span><ul>
	<li> <strong>vec2</strong> <span style="display: inline; color: rgb(0,100,100)">resolution</span>
	<span><ul>
		<li> score/viewport resolution in pixels units</ul></span>
	<li> <strong>float</strong> <span style="display: inline; color: rgb(0,100,100)">globalTime</span>
	<span><ul>
		<li> playback time in seconds</ul></span>
	<li> <strong>float</strong> <span style="display: inline; color: rgb(0,100,100)">baseFrequency</span>
	<span><ul>
		<li> score base frequency</ul></span>
	<li> <strong>float</strong> <span style="display: inline; color: rgb(0,100,100)">octave</span>
	<span><ul>
		<li> score octave range</ul></span>
	<li> <strong>vec4</strong> <span style="display: inline; color: rgb(0,100,100)">mouse</span>
	<span><ul>
		<li> the first two components is the normalized mouse pixel coords updated when the left mouse button and the cursor is moving over the canvas
		<li> the second two components is the normalized mouse pixel coords only updated when the left mouse button is down on the canvas</ul></span>
	<li> <strong>vec4</strong> <span style="display: inline; color: rgb(0,100,100)">date</span>
	<span><ul>
		<li> year
		<li> month
		<li> day
		<li> time in seconds</ul></span>
	<li> <strong>sampler2D</strong> <span style="display: inline; color: rgb(0,100,100)">iInput</span><span style="display: inline; color: rgb(0,100,100)"><strong>N</strong></span>
	<span><ul>
		<li> typical usage: texture2D(iInput0, uv)</ul></span>
	<li> <strong>sampler2D</strong> <span style="display: inline; color: rgb(0,100,100)">pFrame</span>
	<span><ul>
		<li> this uniform will be available when feedback is enabled and contain the previous frame
		<li> typical usage: texture2D(pFrame, uv)</ul></span>
	<li> <strong>vec4N</strong> <span style="display: inline; color: rgb(0,100,100)">keyboard</span>
	<span><ul>
		<li> note-on frequency
		<li> note-on velocity
		<li> note-on elapsed time
		<li> note-on MIDI channel</ul></span>
	<li> <strong>function</strong> <span style="display: inline; color: rgb(0,100,100)">htoy</span>
	<span><ul>
		<li> take a frequency as argument and return its vertical position on the canvas (in pixels units)</ul></span>
	<li> <strong>function</strong> <span style="display: inline; color: rgb(0,100,100)">fline</span>
	<span><ul>
		<li> take a frequency as argument and return either 1 or 0, this is a shortcut to draw a line at a specified frequency, it use the htoy function internally</ul></span>
</ul></span><br><br><a id="subsec6_3"></a><span style="font-size: 120%;"><strong>6.3. The timbre</strong></span><br><br>
It is difficult to define precisely the attributes of a complex sound, simplistic models would say that all complex sounds are a combination of a fundamental frequency and the harmonics which are integer multiple of the fundamental frequency but as you can find on the <a href="https://en.wikipedia.org/wiki/Timbre">Wikipedia article on timbre</a>, there is many more attributes.<br><br>Here is an excerpt of timbre major attributes by Robert Erickson taken from the Wikipedia page:
<span><ul>
	<li> The range between tonal and noiselike character
	<li> The spectral envelope
	<li> The time envelope in terms of rise, duration, and decay
	<li> The changes both of spectral envelope (formant-glide) and fundamental frequency (micro-intonation)
	<li> The prefix, or onset of a sound, quite dissimilar to the ensuing lasting vibration</ul></span>
<br>
<a id="subsec6_4"></a><span style="font-size: 120%;"><strong>6.4. Drawing the fundamental</strong></span><br><br>
The fundamental is the simplest constituent of our timbre (its pitch and lowest frequency) and also the fundamental basis for building the harmonics (also called overtones) etc.<br><br>We will produce a fundamental by drawing a horizontal lines and later on its harmonics, all of that will constitute all the frequencies contained by our sound (aka harmonics, partials etc.), those horizontal lines will have several conditional transformations and other processing applied to them later on to produce complex sounds.<br><br>Here is how to draw a horizontal line which will produce a fundamental 440Hz sine wave:
<pre style="color: inherit; font-size: inherit; background-color: rgb(230,235,220); width: 600px;">
  <span style="display: inline; color: rgb(10,0,130)">void</span> main () {
    <span style="display: inline; color: rgb(10,0,130)">float</span> frequency <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">440.</span>;
    <span style="display: inline; color: rgb(10,0,130)">float</span> l <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;
    <span style="display: inline; color: rgb(10,0,130)">float</span> r <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;<br><br>    <span style="display: inline; color: rgb(60,20,20)">// because this code is executed for each fragments</span>
    <span style="display: inline; color: rgb(60,20,20)">// the horizontal line is defined mathematically</span>
    <span style="display: inline; color: rgb(60,20,20)">// by a simple pre-defined function called fline:</span>
    <span style="display: inline; color: rgb(60,20,20)">// step(abs(gl_FragCoord.y - htoy(frequency)), 0.5);</span>
    <span style="display: inline; color: rgb(60,20,20)">// which return 1 or 0, the color</span>
    <span style="display: inline; color: rgb(60,20,20)">// for the left and right channel aka red and green output color</span>
    l <span style="display: inline; color: rgb(10,100,80)">+=</span> fline(frequency);
    r <span style="display: inline; color: rgb(10,100,80)">+=</span> fline(frequency);<br><br>    <span style="display: inline; color: rgb(60,20,20)">// plot the line</span>
    <span style="display: inline; color: rgb(60,20,20)">// Fragment use the RED and GREEN component</span>
    <span style="display: inline; color: rgb(60,20,20)">// for the LEFT and RIGHT audio channel in stereophonic mode</span>
    <span style="display: inline; color: rgb(60,20,20)">// if monophonic mode is enabled, the alpha component will be used for the audio</span>
    <span style="display: inline; color: rgb(60,20,20)">// in this case all other components are unused</span>
    <span style="display: inline; color: rgb(60,20,20)">// thus the blue component can be used for visuals or debugging etc.</span>
    <span style="display: inline; color: rgb(0,100,0)">gl_FragColor</span> <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(10,0,130)">vec4</span>(l, r, <span style="display: inline; color: rgb(130,0,0)">0.</span>, <span style="display: inline; color: rgb(130,0,0)">0.</span>);
  }
</pre>
<div style="text-align: center; color: inherit; font-size: inherit;"><p>
          <audio controls>
            <source src="audio/fsynth_fundamental.ogg" type="audio/ogg">
          </audio>
        </p></div>
You can verify that the produced horizontal line is a 440Hz sine wave by enabling the axis details tool in the toolbar and point your cursor on the horizontal line:
<a href="gif/freq_details.gif"><div style="text-align: center; color: inherit; font-size: inherit;"><p><img src="gif/freq_details.gif" width="600"></p></div></a>
You might be surprised to see that this is actually not exactly a 440Hz sine wave, the value is rounded due to the way <a rel="tag" href="#score">frequencies are mapped</a>, this can be fixed by increasing the score height to get a more precise mapping, this will require higher processing power however.<br><br><br>
<a id="subsec6_5"></a><span style="font-size: 120%;"><strong>6.5. Drawing harmonics</strong></span><br><br>
Harmonics (also called overtones) are defined as positive integer multiple of the frequency of the fundamental.<br><br>We will extend the previous code by adding a loop:
<pre style="color: inherit; font-size: inherit; background-color: rgb(230,235,220); width: 600px;">
  <span style="display: inline; color: rgb(10,0,130)">void</span> main () {
    <span style="display: inline; color: rgb(10,0,130)">float</span> l <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;
    <span style="display: inline; color: rgb(10,0,130)">float</span> r <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;
    <span style="display: inline; color: rgb(10,0,130)">float</span> base_frequency <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">440.</span>;<br><br>    <span style="display: inline; color: rgb(60,20,20)">// the number of harmonics that we want (including the fundamental)</span>
    <span style="display: inline; color: rgb(60,20,20)">// we define it as "const" because the current GLSL spec.</span>
    <span style="display: inline; color: rgb(60,20,20)">// does not allow dynamic variables for loops index</span>
    <span style="display: inline; color: rgb(10,0,130)">const</span> <span style="display: inline; color: rgb(10,0,130)">float</span> harmonics <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">8.</span>;<br><br>    <span style="display: inline; color: rgb(60,20,20)">// draw a horizontal line for each harmonics</span>
    <span style="display: inline; color: rgb(60,20,20)">// including the fundamental</span>
    <span style="display: inline; color: rgb(10,0,130)">for</span> (<span style="display: inline; color: rgb(10,0,130)">float</span> i <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span>; i <span style="display: inline; color: rgb(10,100,80)">&lt;</span> harmonics; i <span style="display: inline; color: rgb(10,100,80)">+=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span>) {
      <span style="display: inline; color: rgb(60,20,20)">// multiply the fundamental frequency by the index of the current harmonic</span>
      l <span style="display: inline; color: rgb(10,100,80)">+=</span> fline(base_frequency <span style="display: inline; color: rgb(10,100,80)">*</span> i);
      r <span style="display: inline; color: rgb(10,100,80)">+=</span> fline(base_frequency <span style="display: inline; color: rgb(10,100,80)">*</span> i);
    }<br><br>    <span style="display: inline; color: rgb(0,100,0)">gl_FragColor</span> <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(10,0,130)">vec4</span>(l, r, <span style="display: inline; color: rgb(130,0,0)">0.</span>, <span style="display: inline; color: rgb(130,0,0)">0.</span>);
  }
</pre>
<div style="text-align: center; color: inherit; font-size: inherit;"><p>
          <audio controls>
            <source src="audio/fsynth_harmonics.ogg" type="audio/ogg">
          </audio>
        </p></div>
The produced timbre is actually too raw because all our harmonics have the same value...<br><br>We can fix that by attenuating the higher frequencies, this is similar to the concept of filters in common synthesizers, this is really important as harmonics amplitudes is an important parameter for timbre quality, for example, by decreasing the amplitude of our harmonics gradually, we can create a sawtooth wave, an exponential attenuation provide good result generally in audio due to the way humans brain interpret sounds, we could also just attribute different intensity for each of our harmonics:
<pre style="color: inherit; font-size: inherit; background-color: rgb(230,235,220); width: 600px;">
  <span style="display: inline; color: rgb(10,0,130)">void</span> main () {
    <span style="display: inline; color: rgb(10,0,130)">float</span> l <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;
    <span style="display: inline; color: rgb(10,0,130)">float</span> r <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;
    <span style="display: inline; color: rgb(10,0,130)">float</span> base_frequency <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">440.</span>;<br><br>    <span style="display: inline; color: rgb(10,0,130)">float</span> attenuation_<span style="display: inline; color: rgb(10,0,130)">const</span>ant <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">1.95</span>;<br><br>    <span style="display: inline; color: rgb(10,0,130)">const</span> <span style="display: inline; color: rgb(10,0,130)">float</span> harmonics <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">8.</span>;<br><br>    <span style="display: inline; color: rgb(10,0,130)">for</span> (<span style="display: inline; color: rgb(10,0,130)">float</span> i <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span>; i <span style="display: inline; color: rgb(10,100,80)">&lt;</span> harmonics; i <span style="display: inline; color: rgb(10,100,80)">+=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span>) {
      <span style="display: inline; color: rgb(60,20,20)">// exponentially attenuate higher frequencies</span>
      <span style="display: inline; color: rgb(10,0,130)">float</span> a <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span> <span style="display: inline; color: rgb(10,100,80)">/</span> <span style="display: inline; color: rgb(0,100,0)">pow</span>(i, attenuation_<span style="display: inline; color: rgb(10,0,130)">const</span>ant);<br><br>      l <span style="display: inline; color: rgb(10,100,80)">+=</span> fline(base_frequency <span style="display: inline; color: rgb(10,100,80)">*</span> i) <span style="display: inline; color: rgb(10,100,80)">*</span> a;
      r <span style="display: inline; color: rgb(10,100,80)">+=</span> fline(base_frequency <span style="display: inline; color: rgb(10,100,80)">*</span> i) <span style="display: inline; color: rgb(10,100,80)">*</span> a;
    }<br><br>    <span style="display: inline; color: rgb(0,100,0)">gl_FragColor</span> <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(10,0,130)">vec4</span>(l, r, <span style="display: inline; color: rgb(130,0,0)">0.</span>, <span style="display: inline; color: rgb(130,0,0)">0.</span>);
  }
</pre>
<div style="text-align: center; color: inherit; font-size: inherit;"><p>
          <audio controls>
            <source src="audio/fsynth_attenuation.ogg" type="audio/ogg">
          </audio>
        </p></div>
The output is now smoother, our simple timbre sound much better... we will see next how we can play this timbre with a MIDI keyboard.<br><br><br>
<a id="subsec6_6"></a><span style="font-size: 120%;"><strong>6.6. Square and triangle waveform</strong></span><br><br>
We can now produce many basic/common waveforms such as a square wave or triangle wave which has only odd partials:
<pre style="color: inherit; font-size: inherit; background-color: rgb(230,235,220); width: 600px;">
  <span style="display: inline; color: rgb(10,0,130)">void</span> main () {
    <span style="display: inline; color: rgb(10,0,130)">float</span> l <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;
    <span style="display: inline; color: rgb(10,0,130)">float</span> r <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;
    <span style="display: inline; color: rgb(10,0,130)">float</span> base_frequency <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">440.</span>;<br><br>    <span style="display: inline; color: rgb(60,20,20)">// try with a value of 0.25 to produce a waveform close to a square wave</span>
    <span style="display: inline; color: rgb(10,0,130)">float</span> attenuation_<span style="display: inline; color: rgb(10,0,130)">const</span>ant <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">1.95</span>;<br><br>    <span style="display: inline; color: rgb(10,0,130)">const</span> <span style="display: inline; color: rgb(10,0,130)">float</span> harmonics <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">8.</span>;<br><br>    <span style="display: inline; color: rgb(60,20,20)">// notice how we are stepping through odd harmonics</span>
    <span style="display: inline; color: rgb(10,0,130)">for</span> (<span style="display: inline; color: rgb(10,0,130)">float</span> i <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span>; i <span style="display: inline; color: rgb(10,100,80)">&lt;</span> harmonics; i <span style="display: inline; color: rgb(10,100,80)">+=</span> <span style="display: inline; color: rgb(130,0,0)">2.</span>) {
      <span style="display: inline; color: rgb(10,0,130)">float</span> a <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span> <span style="display: inline; color: rgb(10,100,80)">/</span> <span style="display: inline; color: rgb(0,100,0)">pow</span>(i, attenuation_<span style="display: inline; color: rgb(10,0,130)">const</span>ant);<br><br>      l <span style="display: inline; color: rgb(10,100,80)">+=</span> fline(base_frequency <span style="display: inline; color: rgb(10,100,80)">*</span> i) <span style="display: inline; color: rgb(10,100,80)">*</span> a;
      r <span style="display: inline; color: rgb(10,100,80)">+=</span> fline(base_frequency <span style="display: inline; color: rgb(10,100,80)">*</span> i) <span style="display: inline; color: rgb(10,100,80)">*</span> a;
    }<br><br>    <span style="display: inline; color: rgb(0,100,0)">gl_FragColor</span> <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(10,0,130)">vec4</span>(l, r, <span style="display: inline; color: rgb(130,0,0)">0.</span>, <span style="display: inline; color: rgb(130,0,0)">0.</span>);
  }
</pre>
<div style="text-align: center; color: inherit; font-size: inherit;"><p>
          <audio controls>
            <source src="audio/fsynth_square.ogg" type="audio/ogg">
          </audio>
        </p></div>
Both the square wave and triangle wave have odd partials but a triangle wave has gradually much weaker high harmonics.<br><br><br>
<a id="subsec6_7"></a><span style="font-size: 120%;"><strong>6.7. Simulating pulse-width</strong></span><br><br>
Pulse-width is a feature commonly found in analog synthesizer, by changing the width of a pulse it is possible to change the harmonic content, it goes from a square wave at 50% and approach the sound of a crisper sawtooth wave near 0%.
<pre style="color: inherit; font-size: inherit; background-color: rgb(230,235,220); width: 600px;">
  <span style="display: inline; color: rgb(60,20,20)">// #define statement cannot begin on the first line in Fragment</span>
  <span style="display: inline; color: rgb(0,100,0)">#define</span> pi <span style="display: inline; color: rgb(130,0,0)">3.141592653589</span><br><br>  <span style="display: inline; color: rgb(10,0,130)">void</span> main () {
    <span style="display: inline; color: rgb(10,0,130)">float</span> l <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;
    <span style="display: inline; color: rgb(10,0,130)">float</span> r <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;
    <span style="display: inline; color: rgb(10,0,130)">float</span> base_frequency <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">440.</span>;<br><br>    <span style="display: inline; color: rgb(60,20,20)">// will produce a waveform akin to a square wave</span>
    <span style="display: inline; color: rgb(60,20,20)">// try with 0.1 for a waveform akin to a sawtooth wave</span>
    <span style="display: inline; color: rgb(10,0,130)">float</span> pulse_width <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.5</span>;<br><br>    <span style="display: inline; color: rgb(10,0,130)">const</span> <span style="display: inline; color: rgb(10,0,130)">float</span> harmonics <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">16.</span>;<br><br>    <span style="display: inline; color: rgb(10,0,130)">for</span> (<span style="display: inline; color: rgb(10,0,130)">float</span> i <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span>; i <span style="display: inline; color: rgb(10,100,80)">&lt;</span> harmonics; i <span style="display: inline; color: rgb(10,100,80)">+=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span>) {
      <span style="display: inline; color: rgb(60,20,20)">// plot this function with a graph ploting software</span>
      <span style="display: inline; color: rgb(60,20,20)">// for details</span>
      <span style="display: inline; color: rgb(10,0,130)">float</span> pm <span style="display: inline; color: rgb(10,100,80)">=</span> abs(<span style="display: inline; color: rgb(0,100,0)">cos</span>((i <span style="display: inline; color: rgb(10,100,80)">*</span> pi <span style="display: inline; color: rgb(10,100,80)">-</span> pi) <span style="display: inline; color: rgb(10,100,80)">*</span> pulse_width));<br><br>      l <span style="display: inline; color: rgb(10,100,80)">+=</span> fline(base_frequency <span style="display: inline; color: rgb(10,100,80)">*</span> i) <span style="display: inline; color: rgb(10,100,80)">*</span> pm;
      r <span style="display: inline; color: rgb(10,100,80)">+=</span> fline(base_frequency <span style="display: inline; color: rgb(10,100,80)">*</span> i) <span style="display: inline; color: rgb(10,100,80)">*</span> pm;
    }<br><br>    <span style="display: inline; color: rgb(0,100,0)">gl_FragColor</span> <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(10,0,130)">vec4</span>(l, r, <span style="display: inline; color: rgb(130,0,0)">0.</span>, <span style="display: inline; color: rgb(130,0,0)">0.</span>);
  }
</pre>
<div style="text-align: center; color: inherit; font-size: inherit;"><p>
          <audio controls>
            <source src="audio/fsynth_pulsewave.ogg" type="audio/ogg">
          </audio>
        </p></div>
The advantage of a pulse-width in analog synthesizers is that the width can be modulated to produce string-like patches and is an easy way to change the harmonic content.<br><br>Within Fragment, the pulse-width is just one of the unlimited way to change the harmonic content of a timbre.<br><br><br>
<a id="subsec6_8"></a><span style="font-size: 120%;"><strong>6.8. Playing with a MIDI keyboard</strong></span><br><br>
You must have a WebMIDI supported browser (such as Chrome or Opera) to use MIDI messages with Fragment.<br><br>Once your MIDI keyboard is plugged in, you can go in the Fragment MIDI devices dialog and enable it.<br><br>The MIDI data will now be available in a pre-defined <strong>vec4 array</strong> named <strong>keyboard</strong>, the array length is the actual polyphony capability of Fragment, the array contain a series of vec4 items, a vec4 item contain:
<span><ul>
	<li> the note-on frequency
	<li> the note velocity
	<li> the elapsed time since the key was pressed
	<li> the MIDI channel</ul></span>
Important note: There is no notions of "note-off" in Fragment, a note-off is simply an item filled with 0, Fragment will add note-on in order and will reorder the array as necessary, this mean that you can loop over all items and break the loop if an item component is equal to 0, it is possible to detect note-off events by using the previous frame (aka feedback feature).<br><br>Here is how you can use a MIDI keyboard:
<pre style="color: inherit; font-size: inherit; background-color: rgb(230,235,220); width: 600px;">
  <span style="display: inline; color: rgb(10,0,130)">void</span> main () {
    <span style="display: inline; color: rgb(10,0,130)">float</span> l <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;
    <span style="display: inline; color: rgb(10,0,130)">float</span> r <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;<br><br>    <span style="display: inline; color: rgb(10,0,130)">float</span> attenuation_<span style="display: inline; color: rgb(10,0,130)">const</span>ant <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">1.95</span>;<br><br>    <span style="display: inline; color: rgb(10,0,130)">const</span> <span style="display: inline; color: rgb(10,0,130)">float</span> harmonics <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">8.</span>;<br><br>    <span style="display: inline; color: rgb(60,20,20)">// 8 notes polyphony</span>
    <span style="display: inline; color: rgb(60,20,20)">// this can be increased up to the maximal polyphonic capabilities</span>
    <span style="display: inline; color: rgb(60,20,20)">// of Fragment for your platform</span>
    <span style="display: inline; color: rgb(10,0,130)">for</span> (<span style="display: inline; color: rgb(10,0,130)">int</span> k <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,130)">0</span>; k <span style="display: inline; color: rgb(10,100,80)">&lt;</span> <span style="display: inline; color: rgb(130,0,130)">8</span>; k <span style="display: inline; color: rgb(10,100,80)">+=</span> <span style="display: inline; color: rgb(130,0,130)">1</span>) {
      <span style="display: inline; color: rgb(60,20,20)">// we get the note-on data</span>
      <span style="display: inline; color: rgb(10,0,130)">vec4</span> data <span style="display: inline; color: rgb(10,100,80)">=</span> keyboard[k];<br><br>      <span style="display: inline; color: rgb(10,0,130)">float</span> kfrq <span style="display: inline; color: rgb(10,100,80)">=</span> data.x; <span style="display: inline; color: rgb(60,20,20)">// frequency</span>
      <span style="display: inline; color: rgb(10,0,130)">float</span> kvel <span style="display: inline; color: rgb(10,100,80)">=</span> data.y; <span style="display: inline; color: rgb(60,20,20)">// velocity</span>
      <span style="display: inline; color: rgb(10,0,130)">float</span> ktim <span style="display: inline; color: rgb(10,100,80)">=</span> data.z; <span style="display: inline; color: rgb(60,20,20)">// elpased time</span>
      <span style="display: inline; color: rgb(10,0,130)">float</span> kchn <span style="display: inline; color: rgb(10,100,80)">=</span> data.w; <span style="display: inline; color: rgb(60,20,20)">// channel</span><br><br>      <span style="display: inline; color: rgb(60,20,20)">// we quit as soon as there is no more note-on data</span>
      <span style="display: inline; color: rgb(60,20,20)">// this is optional but it might help with performances</span>
      <span style="display: inline; color: rgb(60,20,20)">// so we don't compute harmonics uselessly</span>
      <span style="display: inline; color: rgb(10,0,130)">if</span> (kfrq <span style="display: inline; color: rgb(10,100,80)">==</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>) {
       	break; 
      }<br><br>      <span style="display: inline; color: rgb(10,0,130)">for</span> (<span style="display: inline; color: rgb(10,0,130)">float</span> i <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span>; i <span style="display: inline; color: rgb(10,100,80)">&lt;</span> harmonics; i <span style="display: inline; color: rgb(10,100,80)">+=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span>) {
        <span style="display: inline; color: rgb(10,0,130)">float</span> a <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span> <span style="display: inline; color: rgb(10,100,80)">/</span> <span style="display: inline; color: rgb(0,100,0)">pow</span>(i, attenuation_<span style="display: inline; color: rgb(10,0,130)">const</span>ant);<br><br>        <span style="display: inline; color: rgb(60,20,20)">// we apply the velocity</span>
        l <span style="display: inline; color: rgb(10,100,80)">+=</span> fline(kfrq <span style="display: inline; color: rgb(10,100,80)">*</span> i) <span style="display: inline; color: rgb(10,100,80)">*</span> a <span style="display: inline; color: rgb(10,100,80)">*</span> kvel;
        r <span style="display: inline; color: rgb(10,100,80)">+=</span> fline(kfrq <span style="display: inline; color: rgb(10,100,80)">*</span> i) <span style="display: inline; color: rgb(10,100,80)">*</span> a <span style="display: inline; color: rgb(10,100,80)">*</span> kvel;
      }
    }<br><br>    <span style="display: inline; color: rgb(60,20,20)">// notice how the blue channel is used</span>
    <span style="display: inline; color: rgb(60,20,20)">// this help to get a better visual feedback of the harmonics</span>
    <span style="display: inline; color: rgb(0,100,0)">gl_FragColor</span> <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(10,0,130)">vec4</span>(l, r, l <span style="display: inline; color: rgb(10,100,80)">*</span> <span style="display: inline; color: rgb(130,0,0)">64.</span>, <span style="display: inline; color: rgb(130,0,0)">0.</span>);
  }
</pre>
<div style="text-align: center; color: inherit; font-size: inherit;"><p>
          <audio controls>
            <source src="audio/fsynth_midi.ogg" type="audio/ogg">
          </audio>
        </p></div>
You can now play something with your MIDI keyboard and hear your simple timbre!<br><br>You might find the loop kind of weird, why we don't just loop over all available note-on messages? This is because the default GLSL spec. with WebGL is quite limited when it come to loop features... for example, it does not allow dynamicals indexes however you can use dynamical indexes if your browser has support for WebGL 2.<br><br>All the examples below will use the GLSL version that is the most compatible, if your browser has support for WebGL 2 you can replace this line :
<pre style="color: inherit; font-size: inherit; background-color: rgb(230,235,220); width: 600px;">
    <span style="display: inline; color: rgb(10,0,130)">for</span> (<span style="display: inline; color: rgb(10,0,130)">int</span> k <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,130)">0</span>; k <span style="display: inline; color: rgb(10,100,80)">&lt;</span> <span style="display: inline; color: rgb(130,0,130)">8</span>; k <span style="display: inline; color: rgb(10,100,80)">+=</span> <span style="display: inline; color: rgb(130,0,130)">1</span>) {
</pre>
by this line :
<pre style="color: inherit; font-size: inherit; background-color: rgb(230,235,220); width: 600px;">
    <span style="display: inline; color: rgb(10,0,130)">for</span> (<span style="display: inline; color: rgb(10,0,130)">int</span> k <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,130)">0</span>; k <span style="display: inline; color: rgb(10,100,80)">&lt;</span> keyboard.length(); k <span style="display: inline; color: rgb(10,100,80)">+=</span> <span style="display: inline; color: rgb(130,0,130)">1</span>) {
</pre><br><br><br>
<a id="subsec6_9"></a><span style="font-size: 120%;"><strong>6.9. Simple AR-like envelope</strong></span><br><br>
Our timbre is nice but still too simple, we can fix that by applying an envelope, a mathematical function which will determine the timbre behavior by taking into account the elapsed time when we hit the keys of our MIDI keyboard.<br><br>Fragment allow any envelopes to be done by mathematically defining them, one of the simplest envelope is AR (Attack and Release):
<pre style="color: inherit; font-size: inherit; background-color: rgb(230,235,220); width: 600px;">
  <span style="display: inline; color: rgb(60,20,20)">// a simple function which define </span>
  <span style="display: inline; color: rgb(60,20,20)">// smooth AR-like envelopes, fast attack and slow decays</span>
  <span style="display: inline; color: rgb(60,20,20)">// plot it or see the details of this function below</span>
  <span style="display: inline; color: rgb(60,20,20)">// it's maximum, which is 1.0, happens at exactly x = 1 / k</span>
  <span style="display: inline; color: rgb(60,20,20)">// use k to control the stretching of the function</span>
  <span style="display: inline; color: rgb(10,0,130)">float</span> impulse(<span style="display: inline; color: rgb(10,0,130)">float</span> k, <span style="display: inline; color: rgb(10,0,130)">float</span> x) {
    <span style="display: inline; color: rgb(10,0,130)">float</span> h <span style="display: inline; color: rgb(10,100,80)">=</span> k <span style="display: inline; color: rgb(10,100,80)">*</span> x;
    <span style="display: inline; color: rgb(10,0,130)">return</span> h <span style="display: inline; color: rgb(10,100,80)">*</span> <span style="display: inline; color: rgb(0,100,0)">exp</span>(<span style="display: inline; color: rgb(130,0,0)">1.0</span> <span style="display: inline; color: rgb(10,100,80)">-</span> h);
  }<br><br>  <span style="display: inline; color: rgb(10,0,130)">void</span> main () {
    <span style="display: inline; color: rgb(10,0,130)">float</span> l <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;
    <span style="display: inline; color: rgb(10,0,130)">float</span> r <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;<br><br>    <span style="display: inline; color: rgb(10,0,130)">float</span> attenuation_<span style="display: inline; color: rgb(10,0,130)">const</span>ant <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">1.95</span>;<br><br>    <span style="display: inline; color: rgb(10,0,130)">const</span> <span style="display: inline; color: rgb(10,0,130)">float</span> harmonics <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">8.</span>;<br><br>    <span style="display: inline; color: rgb(10,0,130)">for</span> (<span style="display: inline; color: rgb(10,0,130)">int</span> k <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,130)">0</span>; k <span style="display: inline; color: rgb(10,100,80)">&lt;</span> <span style="display: inline; color: rgb(130,0,130)">8</span>; k <span style="display: inline; color: rgb(10,100,80)">+=</span> <span style="display: inline; color: rgb(130,0,130)">1</span>) {
      <span style="display: inline; color: rgb(10,0,130)">vec4</span> data <span style="display: inline; color: rgb(10,100,80)">=</span> keyboard[k];<br><br>      <span style="display: inline; color: rgb(10,0,130)">float</span> kfrq <span style="display: inline; color: rgb(10,100,80)">=</span> data.x;
      <span style="display: inline; color: rgb(10,0,130)">float</span> kvel <span style="display: inline; color: rgb(10,100,80)">=</span> data.y;
      <span style="display: inline; color: rgb(10,0,130)">float</span> ktim <span style="display: inline; color: rgb(10,100,80)">=</span> data.z;
      <span style="display: inline; color: rgb(10,0,130)">float</span> kchn <span style="display: inline; color: rgb(10,100,80)">=</span> data.w;<br><br>      <span style="display: inline; color: rgb(10,0,130)">if</span> (kfrq <span style="display: inline; color: rgb(10,100,80)">==</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>) {
       	break; 
      }<br><br>      <span style="display: inline; color: rgb(60,20,20)">// we apply the envelope, this envelope has a fast attack</span>
      <span style="display: inline; color: rgb(60,20,20)">// of 62.5ms and a release of 555ms</span>
      <span style="display: inline; color: rgb(10,0,130)">float</span> env_attack <span style="display: inline; color: rgb(10,100,80)">=</span> ktim <span style="display: inline; color: rgb(10,100,80)">*</span> <span style="display: inline; color: rgb(130,0,0)">16.</span>;
      <span style="display: inline; color: rgb(10,0,130)">float</span> env <span style="display: inline; color: rgb(10,100,80)">=</span> kvel <span style="display: inline; color: rgb(10,100,80)">*</span> impulse(<span style="display: inline; color: rgb(130,0,0)">1.</span>, env_attack);<br><br>      <span style="display: inline; color: rgb(10,0,130)">for</span> (<span style="display: inline; color: rgb(10,0,130)">float</span> i <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span>; i <span style="display: inline; color: rgb(10,100,80)">&lt;</span> harmonics; i <span style="display: inline; color: rgb(10,100,80)">+=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span>) {
        <span style="display: inline; color: rgb(10,0,130)">float</span> a <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span> <span style="display: inline; color: rgb(10,100,80)">/</span> <span style="display: inline; color: rgb(0,100,0)">pow</span>(i, attenuation_<span style="display: inline; color: rgb(10,0,130)">const</span>ant);<br><br>        l <span style="display: inline; color: rgb(10,100,80)">+=</span> fline(kfrq <span style="display: inline; color: rgb(10,100,80)">*</span> i) <span style="display: inline; color: rgb(10,100,80)">*</span> a <span style="display: inline; color: rgb(10,100,80)">*</span> env;
        r <span style="display: inline; color: rgb(10,100,80)">+=</span> fline(kfrq <span style="display: inline; color: rgb(10,100,80)">*</span> i) <span style="display: inline; color: rgb(10,100,80)">*</span> a <span style="display: inline; color: rgb(10,100,80)">*</span> env;
      }
    }<br><br>    <span style="display: inline; color: rgb(0,100,0)">gl_FragColor</span> <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(10,0,130)">vec4</span>(l, r, l <span style="display: inline; color: rgb(10,100,80)">+</span> r, <span style="display: inline; color: rgb(130,0,0)">0.</span>);
  }
</pre>
<div style="text-align: center; color: inherit; font-size: inherit;"><p>
          <audio controls>
            <source src="audio/fsynth_ar.ogg" type="audio/ogg">
          </audio>
        </p></div>
You can change the parameters of the envelope to apply other kinds of envelopes.<br><br>Here is a good preview of the envelope models that the <strong>impulse</strong> function generate:
<a href="images/impulse.png"><div style="text-align: center; color: inherit; font-size: inherit;"><p><img src="images/impulse.png" width="512"></p></div></a>
<br>
The sound is still not very interesting yet but now that we know how to generate the envelope, we can do many things such as applying a different envelope to each harmonics:
<pre style="color: inherit; font-size: inherit; background-color: rgb(230,235,220); width: 600px;">
  <span style="display: inline; color: rgb(10,0,130)">float</span> impulse(<span style="display: inline; color: rgb(10,0,130)">float</span> k, <span style="display: inline; color: rgb(10,0,130)">float</span> x) {
    <span style="display: inline; color: rgb(10,0,130)">float</span> h <span style="display: inline; color: rgb(10,100,80)">=</span> k <span style="display: inline; color: rgb(10,100,80)">*</span> x;
    <span style="display: inline; color: rgb(10,0,130)">return</span> h <span style="display: inline; color: rgb(10,100,80)">*</span> <span style="display: inline; color: rgb(0,100,0)">exp</span>(<span style="display: inline; color: rgb(130,0,0)">1.0</span> <span style="display: inline; color: rgb(10,100,80)">-</span> h);
  }<br><br>  <span style="display: inline; color: rgb(10,0,130)">void</span> main () {
    <span style="display: inline; color: rgb(10,0,130)">float</span> l <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;
    <span style="display: inline; color: rgb(10,0,130)">float</span> r <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;<br><br>    <span style="display: inline; color: rgb(10,0,130)">float</span> attenuation_<span style="display: inline; color: rgb(10,0,130)">const</span>ant <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">1.95</span>;<br><br>    <span style="display: inline; color: rgb(60,20,20)">// we will now increase the amount of harmonics</span>
    <span style="display: inline; color: rgb(10,0,130)">const</span> <span style="display: inline; color: rgb(10,0,130)">float</span> harmonics <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">16.</span>;<br><br>    <span style="display: inline; color: rgb(10,0,130)">for</span> (<span style="display: inline; color: rgb(10,0,130)">int</span> k <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,130)">0</span>; k <span style="display: inline; color: rgb(10,100,80)">&lt;</span> <span style="display: inline; color: rgb(130,0,130)">8</span>; k <span style="display: inline; color: rgb(10,100,80)">+=</span> <span style="display: inline; color: rgb(130,0,130)">1</span>) {
      <span style="display: inline; color: rgb(10,0,130)">vec4</span> data <span style="display: inline; color: rgb(10,100,80)">=</span> keyboard[k];<br><br>      <span style="display: inline; color: rgb(10,0,130)">float</span> kfrq <span style="display: inline; color: rgb(10,100,80)">=</span> data.x;
      <span style="display: inline; color: rgb(10,0,130)">float</span> kvel <span style="display: inline; color: rgb(10,100,80)">=</span> data.y;
      <span style="display: inline; color: rgb(10,0,130)">float</span> ktim <span style="display: inline; color: rgb(10,100,80)">=</span> data.z;
      <span style="display: inline; color: rgb(10,0,130)">float</span> kchn <span style="display: inline; color: rgb(10,100,80)">=</span> data.w;<br><br>      <span style="display: inline; color: rgb(10,0,130)">if</span> (kfrq <span style="display: inline; color: rgb(10,100,80)">==</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>) {
       	break; 
      }<br><br>      <span style="display: inline; color: rgb(10,0,130)">float</span> env_attack <span style="display: inline; color: rgb(10,100,80)">=</span> ktim <span style="display: inline; color: rgb(10,100,80)">*</span> <span style="display: inline; color: rgb(130,0,0)">16.</span>;<br><br>      <span style="display: inline; color: rgb(10,0,130)">for</span> (<span style="display: inline; color: rgb(10,0,130)">float</span> i <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span>; i <span style="display: inline; color: rgb(10,100,80)">&lt;</span> harmonics; i <span style="display: inline; color: rgb(10,100,80)">+=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span>) {
        <span style="display: inline; color: rgb(10,0,130)">float</span> a <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span> <span style="display: inline; color: rgb(10,100,80)">/</span> <span style="display: inline; color: rgb(0,100,0)">pow</span>(i, attenuation_<span style="display: inline; color: rgb(10,0,130)">const</span>ant);<br><br>        <span style="display: inline; color: rgb(60,20,20)">// we stretch the envelope per harmonics</span>
        <span style="display: inline; color: rgb(10,0,130)">float</span> env_stretch <span style="display: inline; color: rgb(10,100,80)">=</span> i <span style="display: inline; color: rgb(10,100,80)">/</span> harmonics;
        <span style="display: inline; color: rgb(10,0,130)">float</span> env <span style="display: inline; color: rgb(10,100,80)">=</span> kvel <span style="display: inline; color: rgb(10,100,80)">*</span> impulse(env_stretch, env_attack);<br><br>        l <span style="display: inline; color: rgb(10,100,80)">+=</span> fline(kfrq <span style="display: inline; color: rgb(10,100,80)">*</span> i) <span style="display: inline; color: rgb(10,100,80)">*</span> a <span style="display: inline; color: rgb(10,100,80)">*</span> env;
        r <span style="display: inline; color: rgb(10,100,80)">+=</span> fline(kfrq <span style="display: inline; color: rgb(10,100,80)">*</span> i) <span style="display: inline; color: rgb(10,100,80)">*</span> a <span style="display: inline; color: rgb(10,100,80)">*</span> env;
      }
    }<br><br>    <span style="display: inline; color: rgb(0,100,0)">gl_FragColor</span> <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(10,0,130)">vec4</span>(l, r, l <span style="display: inline; color: rgb(10,100,80)">+</span> r, <span style="display: inline; color: rgb(130,0,0)">0.</span>);
  }
</pre>
<div style="text-align: center; color: inherit; font-size: inherit;"><p>
          <audio controls>
            <source src="audio/fsynth_ar2.ogg" type="audio/ogg">
          </audio>
        </p></div>
The timbre produced by this code is very pleasant, all high frequencies harmonics decay very fast while the fundamental decay slowly, you can hear multiple versions of this by varying parameters such as the attack time or the attenuation constant etc., a very fast attack time sound very pleasant now.<br><br><br>
<a id="subsec6_10"></a><span style="font-size: 120%;"><strong>6.10. Morphing between parameters</strong></span><br><br>
We will now look into getting a better timbre by morphing parameters such as the attenuation or frequencies, due to the nature of Fragment, almost everything can be morphed easily by using mathematical functions:
<pre style="color: inherit; font-size: inherit; background-color: rgb(230,235,220); width: 600px;">
  <span style="display: inline; color: rgb(10,0,130)">float</span> impulse(<span style="display: inline; color: rgb(10,0,130)">float</span> k, <span style="display: inline; color: rgb(10,0,130)">float</span> x) {
    <span style="display: inline; color: rgb(10,0,130)">float</span> h <span style="display: inline; color: rgb(10,100,80)">=</span> k <span style="display: inline; color: rgb(10,100,80)">*</span> x;
    <span style="display: inline; color: rgb(10,0,130)">return</span> h <span style="display: inline; color: rgb(10,100,80)">*</span> <span style="display: inline; color: rgb(0,100,0)">exp</span>(<span style="display: inline; color: rgb(130,0,0)">1.0</span> <span style="display: inline; color: rgb(10,100,80)">-</span> h);
  }<br><br>  <span style="display: inline; color: rgb(10,0,130)">void</span> main () {
    <span style="display: inline; color: rgb(10,0,130)">float</span> l <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;
    <span style="display: inline; color: rgb(10,0,130)">float</span> r <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;<br><br>    <span style="display: inline; color: rgb(10,0,130)">float</span> attenuation_<span style="display: inline; color: rgb(10,0,130)">const</span>ant <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">1.95</span>;<br><br>    <span style="display: inline; color: rgb(10,0,130)">const</span> <span style="display: inline; color: rgb(10,0,130)">float</span> harmonics <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">16.</span>;<br><br>    <span style="display: inline; color: rgb(10,0,130)">for</span> (<span style="display: inline; color: rgb(10,0,130)">int</span> k <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,130)">0</span>; k <span style="display: inline; color: rgb(10,100,80)">&lt;</span> <span style="display: inline; color: rgb(130,0,130)">8</span>; k <span style="display: inline; color: rgb(10,100,80)">+=</span> <span style="display: inline; color: rgb(130,0,130)">1</span>) {
      <span style="display: inline; color: rgb(10,0,130)">vec4</span> data <span style="display: inline; color: rgb(10,100,80)">=</span> keyboard[k];<br><br>      <span style="display: inline; color: rgb(10,0,130)">float</span> kfrq <span style="display: inline; color: rgb(10,100,80)">=</span> data.x;
      <span style="display: inline; color: rgb(10,0,130)">float</span> kvel <span style="display: inline; color: rgb(10,100,80)">=</span> data.y;
      <span style="display: inline; color: rgb(10,0,130)">float</span> ktim <span style="display: inline; color: rgb(10,100,80)">=</span> data.z;
      <span style="display: inline; color: rgb(10,0,130)">float</span> kchn <span style="display: inline; color: rgb(10,100,80)">=</span> data.w;<br><br>      <span style="display: inline; color: rgb(10,0,130)">if</span> (kfrq <span style="display: inline; color: rgb(10,100,80)">==</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>) {
       	break; 
      }<br><br>      <span style="display: inline; color: rgb(10,0,130)">float</span> env_attack <span style="display: inline; color: rgb(10,100,80)">=</span> ktim <span style="display: inline; color: rgb(10,100,80)">*</span> <span style="display: inline; color: rgb(130,0,0)">16.</span>;<br><br>      <span style="display: inline; color: rgb(60,20,20)">// we create a mixing function</span>
      <span style="display: inline; color: rgb(10,0,130)">float</span> mix_f <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.5</span> <span style="display: inline; color: rgb(10,100,80)">*</span> (<span style="display: inline; color: rgb(130,0,0)">1.</span> <span style="display: inline; color: rgb(10,100,80)">+</span> <span style="display: inline; color: rgb(0,100,0)">sin</span>(ktim <span style="display: inline; color: rgb(10,100,80)">*</span> <span style="display: inline; color: rgb(130,0,0)">20.</span>));<br><br>      <span style="display: inline; color: rgb(10,0,130)">for</span> (<span style="display: inline; color: rgb(10,0,130)">float</span> i <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span>; i <span style="display: inline; color: rgb(10,100,80)">&lt;</span> harmonics; i <span style="display: inline; color: rgb(10,100,80)">+=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span>) {
        <span style="display: inline; color: rgb(10,0,130)">float</span> a <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span> <span style="display: inline; color: rgb(10,100,80)">/</span> <span style="display: inline; color: rgb(0,100,0)">pow</span>(i, attenuation_<span style="display: inline; color: rgb(10,0,130)">const</span>ant);<br><br>        <span style="display: inline; color: rgb(60,20,20)">// we setup another attenuation value which</span>
        <span style="display: inline; color: rgb(60,20,20)">// is a bit higher than the previous one</span>
        <span style="display: inline; color: rgb(10,0,130)">float</span> a<span style="display: inline; color: rgb(130,0,130)">2</span> <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span> <span style="display: inline; color: rgb(10,100,80)">/</span> <span style="display: inline; color: rgb(0,100,0)">pow</span>(i, attenuation_<span style="display: inline; color: rgb(10,0,130)">const</span>ant <span style="display: inline; color: rgb(10,100,80)">*</span> <span style="display: inline; color: rgb(130,0,0)">1.3</span>);<br><br>        <span style="display: inline; color: rgb(10,0,130)">float</span> env_stretch <span style="display: inline; color: rgb(10,100,80)">=</span> i <span style="display: inline; color: rgb(10,100,80)">/</span> harmonics;
        <span style="display: inline; color: rgb(10,0,130)">float</span> env <span style="display: inline; color: rgb(10,100,80)">=</span> kvel <span style="display: inline; color: rgb(10,100,80)">*</span> impulse(env_stretch, env_attack);<br><br>        <span style="display: inline; color: rgb(60,20,20)">// we now mix our attenuations so that</span>
        <span style="display: inline; color: rgb(60,20,20)">// higher harmonics oscillate between both </span>
        <span style="display: inline; color: rgb(60,20,20)">// kind of attenuations smoothly</span>
        a <span style="display: inline; color: rgb(10,100,80)">=</span> mix(a, a<span style="display: inline; color: rgb(130,0,130)">2</span>, mix_f);<br><br>        l <span style="display: inline; color: rgb(10,100,80)">+=</span> fline(kfrq <span style="display: inline; color: rgb(10,100,80)">*</span> i) <span style="display: inline; color: rgb(10,100,80)">*</span> a <span style="display: inline; color: rgb(10,100,80)">*</span> env;
        r <span style="display: inline; color: rgb(10,100,80)">+=</span> fline(kfrq <span style="display: inline; color: rgb(10,100,80)">*</span> i) <span style="display: inline; color: rgb(10,100,80)">*</span> a <span style="display: inline; color: rgb(10,100,80)">*</span> env;
      }
    }<br><br>    <span style="display: inline; color: rgb(0,100,0)">gl_FragColor</span> <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(10,0,130)">vec4</span>(l, r, l <span style="display: inline; color: rgb(10,100,80)">+</span> r, <span style="display: inline; color: rgb(130,0,0)">0.</span>);
  }
</pre>
<div style="text-align: center; color: inherit; font-size: inherit;"><p>
          <audio controls>
            <source src="audio/fsynth_morph.ogg" type="audio/ogg">
          </audio>
        </p></div>
The timbre is much more pleasant, especially if you play some chords.<br><br>This is just an example but you can now imagine the amount of possibilities, very complex timbres can be created easily by applying custom functions and mixing between several parameters!<br><br>For example, we could do a tremolo or vibrato effect very easily by modulating our harmonics or frequencies quickly!<br><br>Fragment offer a limitless landscape for any creative minds willing to experiment.<br><br><br>
<a id="subsec6_11"></a><span style="font-size: 120%;"><strong>6.11. ADSR envelope</strong></span><br><br>
We will now replace our AR envelope by the more complex ADSR envelope, ADSR mean Attack, Decay, Sustain, Release, this is a classic and is the most commonly used envelope, this will enhance our possibilities.
<pre style="color: inherit; font-size: inherit; background-color: rgb(230,235,220); width: 600px;">
  <span style="display: inline; color: rgb(10,0,130)">float</span> adsr(<span style="display: inline; color: rgb(10,0,130)">float</span> t, <span style="display: inline; color: rgb(10,0,130)">vec4</span> v, <span style="display: inline; color: rgb(10,0,130)">float</span> s) {
    v.xyw <span style="display: inline; color: rgb(10,100,80)">=</span> max(<span style="display: inline; color: rgb(10,0,130)">vec3</span>(<span style="display: inline; color: rgb(130,0,0)">2.2</span>e<span style="display: inline; color: rgb(10,100,80)">-</span><span style="display: inline; color: rgb(130,0,130)">05</span>), v.xyw);
    <span style="display: inline; color: rgb(60,20,20)">// attack term</span>
    <span style="display: inline; color: rgb(10,0,130)">float</span> ta <span style="display: inline; color: rgb(10,100,80)">=</span> t<span style="display: inline; color: rgb(10,100,80)">/</span>v.x;
    <span style="display: inline; color: rgb(60,20,20)">// decay / sustain amplitude term</span>
    <span style="display: inline; color: rgb(10,0,130)">float</span> td <span style="display: inline; color: rgb(10,100,80)">=</span> max(s, <span style="display: inline; color: rgb(130,0,0)">1.0</span><span style="display: inline; color: rgb(10,100,80)">-</span>(t<span style="display: inline; color: rgb(10,100,80)">-</span>v.x)<span style="display: inline; color: rgb(10,100,80)">*</span>(<span style="display: inline; color: rgb(130,0,0)">1.0</span><span style="display: inline; color: rgb(10,100,80)">-</span>s)<span style="display: inline; color: rgb(10,100,80)">/</span>v.y);
    <span style="display: inline; color: rgb(60,20,20)">// length / release term</span>
    <span style="display: inline; color: rgb(10,0,130)">float</span> tr <span style="display: inline; color: rgb(10,100,80)">=</span> (<span style="display: inline; color: rgb(130,0,0)">1.0</span> <span style="display: inline; color: rgb(10,100,80)">-</span> max(<span style="display: inline; color: rgb(130,0,0)">0.0</span>,t<span style="display: inline; color: rgb(10,100,80)">-</span>(v.x<span style="display: inline; color: rgb(10,100,80)">+</span>v.y<span style="display: inline; color: rgb(10,100,80)">+</span>v.z))<span style="display: inline; color: rgb(10,100,80)">/</span>v.w);
    <span style="display: inline; color: rgb(10,0,130)">return</span> max(<span style="display: inline; color: rgb(130,0,0)">0.0</span>, min(ta, tr<span style="display: inline; color: rgb(10,100,80)">*</span>td));
  }<br><br>  <span style="display: inline; color: rgb(10,0,130)">void</span> main () {
    <span style="display: inline; color: rgb(10,0,130)">float</span> l <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;
    <span style="display: inline; color: rgb(10,0,130)">float</span> r <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;<br><br>    <span style="display: inline; color: rgb(10,0,130)">float</span> attenuation_<span style="display: inline; color: rgb(10,0,130)">const</span>ant <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">1.95</span>;<br><br>    <span style="display: inline; color: rgb(10,0,130)">const</span> <span style="display: inline; color: rgb(10,0,130)">float</span> harmonics <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">16.</span>;<br><br>    <span style="display: inline; color: rgb(10,0,130)">for</span> (<span style="display: inline; color: rgb(10,0,130)">int</span> k <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,130)">0</span>; k <span style="display: inline; color: rgb(10,100,80)">&lt;</span> <span style="display: inline; color: rgb(130,0,130)">8</span>; k <span style="display: inline; color: rgb(10,100,80)">+=</span> <span style="display: inline; color: rgb(130,0,130)">1</span>) {
      <span style="display: inline; color: rgb(10,0,130)">vec4</span> data <span style="display: inline; color: rgb(10,100,80)">=</span> keyboard[k];<br><br>      <span style="display: inline; color: rgb(10,0,130)">float</span> kfrq <span style="display: inline; color: rgb(10,100,80)">=</span> data.x;
      <span style="display: inline; color: rgb(10,0,130)">float</span> kvel <span style="display: inline; color: rgb(10,100,80)">=</span> data.y;
      <span style="display: inline; color: rgb(10,0,130)">float</span> ktim <span style="display: inline; color: rgb(10,100,80)">=</span> data.z;
      <span style="display: inline; color: rgb(10,0,130)">float</span> kchn <span style="display: inline; color: rgb(10,100,80)">=</span> data.w;<br><br>      <span style="display: inline; color: rgb(10,0,130)">if</span> (kfrq <span style="display: inline; color: rgb(10,100,80)">==</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>) {
       	break; 
      }<br><br>      <span style="display: inline; color: rgb(10,0,130)">float</span> mix_f <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.5</span> <span style="display: inline; color: rgb(10,100,80)">*</span> (<span style="display: inline; color: rgb(130,0,0)">1.</span> <span style="display: inline; color: rgb(10,100,80)">+</span> <span style="display: inline; color: rgb(0,100,0)">sin</span>(ktim <span style="display: inline; color: rgb(10,100,80)">*</span> <span style="display: inline; color: rgb(130,0,0)">2.</span>));<br><br>      <span style="display: inline; color: rgb(10,0,130)">for</span> (<span style="display: inline; color: rgb(10,0,130)">float</span> i <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span>; i <span style="display: inline; color: rgb(10,100,80)">&lt;</span> harmonics; i <span style="display: inline; color: rgb(10,100,80)">+=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span>) {
        <span style="display: inline; color: rgb(10,0,130)">float</span> a <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span> <span style="display: inline; color: rgb(10,100,80)">/</span> <span style="display: inline; color: rgb(0,100,0)">pow</span>(i, attenuation_<span style="display: inline; color: rgb(10,0,130)">const</span>ant <span style="display: inline; color: rgb(10,100,80)">*</span> <span style="display: inline; color: rgb(130,0,0)">1.1</span>);<br><br>        <span style="display: inline; color: rgb(10,0,130)">float</span> a<span style="display: inline; color: rgb(130,0,130)">2</span> <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span> <span style="display: inline; color: rgb(10,100,80)">/</span> <span style="display: inline; color: rgb(0,100,0)">pow</span>(i, attenuation_<span style="display: inline; color: rgb(10,0,130)">const</span>ant <span style="display: inline; color: rgb(10,100,80)">*</span> <span style="display: inline; color: rgb(130,0,0)">1.3</span>);<br><br>        <span style="display: inline; color: rgb(60,20,20)">// we now replace our old impulse function by the adsr function</span>
        <span style="display: inline; color: rgb(60,20,20)">// which take three arguments</span>
        <span style="display: inline; color: rgb(60,20,20)">// time, a vec4 with ADSR parameters and the value to decay to</span>
        <span style="display: inline; color: rgb(10,0,130)">float</span> attack <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.25</span>; <span style="display: inline; color: rgb(60,20,20)">// 250ms attack</span>
        <span style="display: inline; color: rgb(10,0,130)">float</span> decay <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span>; <span style="display: inline; color: rgb(60,20,20)">// 1 sec decay (to 0.25, see decay_amp)</span>
        <span style="display: inline; color: rgb(10,0,130)">float</span> sustain <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>; <span style="display: inline; color: rgb(60,20,20)">// no sustain</span>
        <span style="display: inline; color: rgb(10,0,130)">float</span> release <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.25</span>; <span style="display: inline; color: rgb(60,20,20)">// 250ms release</span>
        <span style="display: inline; color: rgb(10,0,130)">float</span> decay_amp <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.25</span>;
        <span style="display: inline; color: rgb(10,0,130)">float</span> env <span style="display: inline; color: rgb(10,100,80)">=</span> kvel <span style="display: inline; color: rgb(10,100,80)">*</span> adsr(ktim, <span style="display: inline; color: rgb(10,0,130)">vec4</span>(attack, decay, sustain, release), decay_amp);<br><br>        a <span style="display: inline; color: rgb(10,100,80)">=</span> mix(a, a<span style="display: inline; color: rgb(130,0,130)">2</span>, mix_f);<br><br>        l <span style="display: inline; color: rgb(10,100,80)">+=</span> fline(kfrq <span style="display: inline; color: rgb(10,100,80)">*</span> i) <span style="display: inline; color: rgb(10,100,80)">*</span> a <span style="display: inline; color: rgb(10,100,80)">*</span> env;
        r <span style="display: inline; color: rgb(10,100,80)">+=</span> fline(kfrq <span style="display: inline; color: rgb(10,100,80)">*</span> i) <span style="display: inline; color: rgb(10,100,80)">*</span> a <span style="display: inline; color: rgb(10,100,80)">*</span> env;
      }
    }<br><br>    <span style="display: inline; color: rgb(0,100,0)">gl_FragColor</span> <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(10,0,130)">vec4</span>(l, r, l <span style="display: inline; color: rgb(10,100,80)">+</span> r, <span style="display: inline; color: rgb(130,0,0)">0.</span>);
  }
</pre>
<div style="text-align: center; color: inherit; font-size: inherit;"><p>
          <audio controls>
            <source src="audio/fsynth_adsr.ogg" type="audio/ogg">
          </audio>
        </p></div>
<br>
<a id="subsec6_12"></a><span style="font-size: 120%;"><strong>6.12. Filters</strong></span><br><br>
Filters play an important role in sound design, we will see in this section how to apply more powerful and flexible filters with parameters that we can modulate, we will especially recreate generic filters such as low-pass, high-pass etc.
<br>
<a id="subsubsec6_12_1"></a><br><br><strong>6.12.1. Low-pass filter (LPF)</strong><br><br>
A low-pass filter is a filter that passes signals with a frequency lower than a certain cutoff frequency and attenuates signals with frequencies higher than the cutoff frequency.<br><br>We will use the low-pass filter as a prototype filter, which mean that we will build all the other filters from this one.<br><br><a href="images/lpf.png"><div style="text-align: center; color: inherit; font-size: inherit;"><p><img src="images/lpf.png" width="541"></p></div></a>
<div style="text-align: center; color: inherit; font-size: inherit;"><p>The graph of the lpf(x, 0., 1.5) function</p></div><br><br>The attenuation function that we have used so far is a kind of simple low-pass filter.
<pre style="color: inherit; font-size: inherit; background-color: rgb(230,235,220); width: 600px;">
  <span style="display: inline; color: rgb(10,0,130)">float</span> adsr(<span style="display: inline; color: rgb(10,0,130)">float</span> t, <span style="display: inline; color: rgb(10,0,130)">vec4</span> v, <span style="display: inline; color: rgb(10,0,130)">float</span> s) {
    v.xyw <span style="display: inline; color: rgb(10,100,80)">=</span> max(<span style="display: inline; color: rgb(10,0,130)">vec3</span>(<span style="display: inline; color: rgb(130,0,0)">2.2</span>e<span style="display: inline; color: rgb(10,100,80)">-</span><span style="display: inline; color: rgb(130,0,130)">05</span>), v.xyw);
    <span style="display: inline; color: rgb(10,0,130)">float</span> ta <span style="display: inline; color: rgb(10,100,80)">=</span> t<span style="display: inline; color: rgb(10,100,80)">/</span>v.x;
    <span style="display: inline; color: rgb(10,0,130)">float</span> td <span style="display: inline; color: rgb(10,100,80)">=</span> max(s, <span style="display: inline; color: rgb(130,0,0)">1.0</span><span style="display: inline; color: rgb(10,100,80)">-</span>(t<span style="display: inline; color: rgb(10,100,80)">-</span>v.x)<span style="display: inline; color: rgb(10,100,80)">*</span>(<span style="display: inline; color: rgb(130,0,0)">1.0</span><span style="display: inline; color: rgb(10,100,80)">-</span>s)<span style="display: inline; color: rgb(10,100,80)">/</span>v.y);
    <span style="display: inline; color: rgb(10,0,130)">float</span> tr <span style="display: inline; color: rgb(10,100,80)">=</span> (<span style="display: inline; color: rgb(130,0,0)">1.0</span> <span style="display: inline; color: rgb(10,100,80)">-</span> max(<span style="display: inline; color: rgb(130,0,0)">0.0</span>,t<span style="display: inline; color: rgb(10,100,80)">-</span>(v.x<span style="display: inline; color: rgb(10,100,80)">+</span>v.y<span style="display: inline; color: rgb(10,100,80)">+</span>v.z))<span style="display: inline; color: rgb(10,100,80)">/</span>v.w);
    <span style="display: inline; color: rgb(10,0,130)">return</span> max(<span style="display: inline; color: rgb(130,0,0)">0.0</span>, min(ta, tr<span style="display: inline; color: rgb(10,100,80)">*</span>td));
  }<br><br>  <span style="display: inline; color: rgb(60,20,20)">// low-pass filter</span>
  <span style="display: inline; color: rgb(60,20,20)">// x is the current normalized position</span>
  <span style="display: inline; color: rgb(60,20,20)">// c is the cutoff position</span>
  <span style="display: inline; color: rgb(60,20,20)">// s is the slope</span>
  <span style="display: inline; color: rgb(10,0,130)">float</span> lpf(<span style="display: inline; color: rgb(10,0,130)">float</span> x, <span style="display: inline; color: rgb(10,0,130)">float</span> c, <span style="display: inline; color: rgb(10,0,130)">float</span> s) {
    <span style="display: inline; color: rgb(10,0,130)">return</span> .<span style="display: inline; color: rgb(130,0,130)">5</span> <span style="display: inline; color: rgb(10,100,80)">+</span> .<span style="display: inline; color: rgb(130,0,130)">5</span> <span style="display: inline; color: rgb(10,100,80)">*</span>(<span style="display: inline; color: rgb(0,100,0)">atan</span>(s<span style="display: inline; color: rgb(10,100,80)">*</span><span style="display: inline; color: rgb(0,100,0)">cos</span>(<span style="display: inline; color: rgb(130,0,0)">3.141592653</span> <span style="display: inline; color: rgb(10,100,80)">*</span> min(max((x<span style="display: inline; color: rgb(10,100,80)">-</span>c) <span style="display: inline; color: rgb(10,100,80)">*</span> s,<span style="display: inline; color: rgb(130,0,0)">0.</span>),<span style="display: inline; color: rgb(130,0,0)">1.</span>)))<span style="display: inline; color: rgb(10,100,80)">/</span><span style="display: inline; color: rgb(0,100,0)">atan</span>(s));
  }<br><br>  <span style="display: inline; color: rgb(10,0,130)">void</span> main () {
    <span style="display: inline; color: rgb(60,20,20)">// we will need the current normalized coordinates</span>
    <span style="display: inline; color: rgb(10,0,130)">vec2</span> uv <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(0,100,0)">gl_FragCoord</span>.xy <span style="display: inline; color: rgb(10,100,80)">/</span> <span style="display: inline; color: rgb(0,100,100)">resolution</span>.xy;<br><br>    <span style="display: inline; color: rgb(10,0,130)">float</span> l <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;
    <span style="display: inline; color: rgb(10,0,130)">float</span> r <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;<br><br>    <span style="display: inline; color: rgb(10,0,130)">const</span> <span style="display: inline; color: rgb(10,0,130)">float</span> harmonics <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">16.</span>;<br><br>    <span style="display: inline; color: rgb(10,0,130)">for</span> (<span style="display: inline; color: rgb(10,0,130)">int</span> k <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,130)">0</span>; k <span style="display: inline; color: rgb(10,100,80)">&lt;</span> <span style="display: inline; color: rgb(130,0,130)">8</span>; k <span style="display: inline; color: rgb(10,100,80)">+=</span> <span style="display: inline; color: rgb(130,0,130)">1</span>) {
      <span style="display: inline; color: rgb(10,0,130)">vec4</span> data <span style="display: inline; color: rgb(10,100,80)">=</span> keyboard[k];<br><br>      <span style="display: inline; color: rgb(10,0,130)">float</span> kfrq <span style="display: inline; color: rgb(10,100,80)">=</span> data.x;
      <span style="display: inline; color: rgb(10,0,130)">float</span> kvel <span style="display: inline; color: rgb(10,100,80)">=</span> data.y;
      <span style="display: inline; color: rgb(10,0,130)">float</span> ktim <span style="display: inline; color: rgb(10,100,80)">=</span> data.z;
      <span style="display: inline; color: rgb(10,0,130)">float</span> kchn <span style="display: inline; color: rgb(10,100,80)">=</span> data.w;<br><br>      <span style="display: inline; color: rgb(10,0,130)">if</span> (kfrq <span style="display: inline; color: rgb(10,100,80)">==</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>) {
       	break; 
      }<br><br>      <span style="display: inline; color: rgb(60,20,20)">// the htoy function take a frequency as argument</span>
      <span style="display: inline; color: rgb(60,20,20)">// and return its position on the canvas</span>
      <span style="display: inline; color: rgb(60,20,20)">// we then normalize the position</span>
      <span style="display: inline; color: rgb(60,20,20)">// the base frequency of our note will be directly used as the cutoff frequency</span>
      <span style="display: inline; color: rgb(10,0,130)">float</span> cutoff <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(0,100,100)">htoy</span>(kfrq) <span style="display: inline; color: rgb(10,100,80)">/</span> <span style="display: inline; color: rgb(0,100,100)">resolution</span>.y;
      <span style="display: inline; color: rgb(10,0,130)">for</span> (<span style="display: inline; color: rgb(10,0,130)">float</span> i <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span>; i <span style="display: inline; color: rgb(10,100,80)">&lt;</span> harmonics; i <span style="display: inline; color: rgb(10,100,80)">+=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span>) {
        <span style="display: inline; color: rgb(60,20,20)">// our slope factor, high frequencies will be attenuated better</span>
        <span style="display: inline; color: rgb(10,0,130)">float</span> slope <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">3.</span>;
        <span style="display: inline; color: rgb(10,0,130)">float</span> f <span style="display: inline; color: rgb(10,100,80)">=</span> lpf(uv.y, cutoff, slope);<br><br>        <span style="display: inline; color: rgb(10,0,130)">float</span> attack <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.05</span>;
        <span style="display: inline; color: rgb(10,0,130)">float</span> decay <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.6</span>;
        <span style="display: inline; color: rgb(10,0,130)">float</span> sustain <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;
        <span style="display: inline; color: rgb(10,0,130)">float</span> release <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.25</span>;
        <span style="display: inline; color: rgb(10,0,130)">float</span> dec_amp <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;
        <span style="display: inline; color: rgb(10,0,130)">float</span> env <span style="display: inline; color: rgb(10,100,80)">=</span> kvel <span style="display: inline; color: rgb(10,100,80)">*</span> adsr(ktim, <span style="display: inline; color: rgb(10,0,130)">vec4</span>(attack, decay, sustain, release), dec_amp);<br><br>        l <span style="display: inline; color: rgb(10,100,80)">+=</span> fline(kfrq <span style="display: inline; color: rgb(10,100,80)">*</span> i) <span style="display: inline; color: rgb(10,100,80)">*</span> f <span style="display: inline; color: rgb(10,100,80)">*</span> env;
        r <span style="display: inline; color: rgb(10,100,80)">+=</span> fline(kfrq <span style="display: inline; color: rgb(10,100,80)">*</span> i) <span style="display: inline; color: rgb(10,100,80)">*</span> f <span style="display: inline; color: rgb(10,100,80)">*</span> env;
      }
    }<br><br>    <span style="display: inline; color: rgb(0,100,0)">gl_FragColor</span> <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(10,0,130)">vec4</span>(l, r, <span style="display: inline; color: rgb(130,0,0)">0.</span>, <span style="display: inline; color: rgb(130,0,0)">0.</span>);
  }
</pre>
<div style="text-align: center; color: inherit; font-size: inherit;"><p>
          <audio controls>
            <source src="audio/fsynth_lpf.ogg" type="audio/ogg">
          </audio>
        </p></div>
We can now modulate the filter parameters to change the timbre, we will vary the slope factor of our filter:
<pre style="color: inherit; font-size: inherit; background-color: rgb(230,235,220); width: 600px;">
  <span style="display: inline; color: rgb(10,0,130)">float</span> adsr(<span style="display: inline; color: rgb(10,0,130)">float</span> t, <span style="display: inline; color: rgb(10,0,130)">vec4</span> v, <span style="display: inline; color: rgb(10,0,130)">float</span> s) {
    v.xyw <span style="display: inline; color: rgb(10,100,80)">=</span> max(<span style="display: inline; color: rgb(10,0,130)">vec3</span>(<span style="display: inline; color: rgb(130,0,0)">2.2</span>e<span style="display: inline; color: rgb(10,100,80)">-</span><span style="display: inline; color: rgb(130,0,130)">05</span>), v.xyw);
    <span style="display: inline; color: rgb(10,0,130)">float</span> ta <span style="display: inline; color: rgb(10,100,80)">=</span> t<span style="display: inline; color: rgb(10,100,80)">/</span>v.x;
    <span style="display: inline; color: rgb(10,0,130)">float</span> td <span style="display: inline; color: rgb(10,100,80)">=</span> max(s, <span style="display: inline; color: rgb(130,0,0)">1.0</span><span style="display: inline; color: rgb(10,100,80)">-</span>(t<span style="display: inline; color: rgb(10,100,80)">-</span>v.x)<span style="display: inline; color: rgb(10,100,80)">*</span>(<span style="display: inline; color: rgb(130,0,0)">1.0</span><span style="display: inline; color: rgb(10,100,80)">-</span>s)<span style="display: inline; color: rgb(10,100,80)">/</span>v.y);
    <span style="display: inline; color: rgb(10,0,130)">float</span> tr <span style="display: inline; color: rgb(10,100,80)">=</span> (<span style="display: inline; color: rgb(130,0,0)">1.0</span> <span style="display: inline; color: rgb(10,100,80)">-</span> max(<span style="display: inline; color: rgb(130,0,0)">0.0</span>,t<span style="display: inline; color: rgb(10,100,80)">-</span>(v.x<span style="display: inline; color: rgb(10,100,80)">+</span>v.y<span style="display: inline; color: rgb(10,100,80)">+</span>v.z))<span style="display: inline; color: rgb(10,100,80)">/</span>v.w);
    <span style="display: inline; color: rgb(10,0,130)">return</span> max(<span style="display: inline; color: rgb(130,0,0)">0.0</span>, min(ta, tr<span style="display: inline; color: rgb(10,100,80)">*</span>td));
  }<br><br>  <span style="display: inline; color: rgb(10,0,130)">float</span> lpf(<span style="display: inline; color: rgb(10,0,130)">float</span> x, <span style="display: inline; color: rgb(10,0,130)">float</span> c, <span style="display: inline; color: rgb(10,0,130)">float</span> s) {
    <span style="display: inline; color: rgb(10,0,130)">return</span> .<span style="display: inline; color: rgb(130,0,130)">5</span> <span style="display: inline; color: rgb(10,100,80)">+</span> .<span style="display: inline; color: rgb(130,0,130)">5</span> <span style="display: inline; color: rgb(10,100,80)">*</span>(<span style="display: inline; color: rgb(0,100,0)">atan</span>(s<span style="display: inline; color: rgb(10,100,80)">*</span><span style="display: inline; color: rgb(0,100,0)">cos</span>(<span style="display: inline; color: rgb(130,0,0)">3.141592653</span> <span style="display: inline; color: rgb(10,100,80)">*</span> min(max((x<span style="display: inline; color: rgb(10,100,80)">-</span>c) <span style="display: inline; color: rgb(10,100,80)">*</span> s,<span style="display: inline; color: rgb(130,0,0)">0.</span>),<span style="display: inline; color: rgb(130,0,0)">1.</span>)))<span style="display: inline; color: rgb(10,100,80)">/</span><span style="display: inline; color: rgb(0,100,0)">atan</span>(s));
  }<br><br>  <span style="display: inline; color: rgb(10,0,130)">void</span> main () {
    <span style="display: inline; color: rgb(10,0,130)">vec2</span> uv <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(0,100,0)">gl_FragCoord</span>.xy <span style="display: inline; color: rgb(10,100,80)">/</span> <span style="display: inline; color: rgb(0,100,100)">resolution</span>.xy;<br><br>    <span style="display: inline; color: rgb(10,0,130)">float</span> l <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;
    <span style="display: inline; color: rgb(10,0,130)">float</span> r <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;<br><br>    <span style="display: inline; color: rgb(10,0,130)">const</span> <span style="display: inline; color: rgb(10,0,130)">float</span> harmonics <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">16.</span>;<br><br>    <span style="display: inline; color: rgb(10,0,130)">for</span> (<span style="display: inline; color: rgb(10,0,130)">int</span> k <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,130)">0</span>; k <span style="display: inline; color: rgb(10,100,80)">&lt;</span> <span style="display: inline; color: rgb(130,0,130)">8</span>; k <span style="display: inline; color: rgb(10,100,80)">+=</span> <span style="display: inline; color: rgb(130,0,130)">1</span>) {
      <span style="display: inline; color: rgb(10,0,130)">vec4</span> data <span style="display: inline; color: rgb(10,100,80)">=</span> keyboard[k];<br><br>      <span style="display: inline; color: rgb(10,0,130)">float</span> kfrq <span style="display: inline; color: rgb(10,100,80)">=</span> data.x;
      <span style="display: inline; color: rgb(10,0,130)">float</span> kvel <span style="display: inline; color: rgb(10,100,80)">=</span> data.y;
      <span style="display: inline; color: rgb(10,0,130)">float</span> ktim <span style="display: inline; color: rgb(10,100,80)">=</span> data.z;
      <span style="display: inline; color: rgb(10,0,130)">float</span> kchn <span style="display: inline; color: rgb(10,100,80)">=</span> data.w;<br><br>      <span style="display: inline; color: rgb(10,0,130)">if</span> (kfrq <span style="display: inline; color: rgb(10,100,80)">==</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>) {
       	break; 
      }<br><br>      <span style="display: inline; color: rgb(10,0,130)">float</span> cutoff <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(0,100,100)">htoy</span>(kfrq) <span style="display: inline; color: rgb(10,100,80)">/</span> <span style="display: inline; color: rgb(0,100,100)">resolution</span>.y;<br><br>      <span style="display: inline; color: rgb(60,20,20)">// we vary the slope a bit</span>
      <span style="display: inline; color: rgb(10,0,130)">float</span> slope <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">3.</span> <span style="display: inline; color: rgb(10,100,80)">+</span> <span style="display: inline; color: rgb(0,100,0)">sin</span>(ktim <span style="display: inline; color: rgb(10,100,80)">*</span> <span style="display: inline; color: rgb(130,0,0)">4.</span>);<br><br>      <span style="display: inline; color: rgb(10,0,130)">for</span> (<span style="display: inline; color: rgb(10,0,130)">float</span> i <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span>; i <span style="display: inline; color: rgb(10,100,80)">&lt;</span> harmonics; i <span style="display: inline; color: rgb(10,100,80)">+=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span>) {
        <span style="display: inline; color: rgb(10,0,130)">float</span> f <span style="display: inline; color: rgb(10,100,80)">=</span> lpf(uv.y, cutoff, slope);<br><br>        <span style="display: inline; color: rgb(10,0,130)">float</span> attack <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.05</span>;
        <span style="display: inline; color: rgb(10,0,130)">float</span> decay <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.6</span>;
        <span style="display: inline; color: rgb(10,0,130)">float</span> sustain <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;
        <span style="display: inline; color: rgb(10,0,130)">float</span> release <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.25</span>;
        <span style="display: inline; color: rgb(10,0,130)">float</span> dec_amp <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;
        <span style="display: inline; color: rgb(10,0,130)">float</span> env <span style="display: inline; color: rgb(10,100,80)">=</span> kvel <span style="display: inline; color: rgb(10,100,80)">*</span> adsr(ktim, <span style="display: inline; color: rgb(10,0,130)">vec4</span>(attack, decay, sustain, release), dec_amp);<br><br>        l <span style="display: inline; color: rgb(10,100,80)">+=</span> fline(kfrq <span style="display: inline; color: rgb(10,100,80)">*</span> i) <span style="display: inline; color: rgb(10,100,80)">*</span> f <span style="display: inline; color: rgb(10,100,80)">*</span> env;
        r <span style="display: inline; color: rgb(10,100,80)">+=</span> fline(kfrq <span style="display: inline; color: rgb(10,100,80)">*</span> i) <span style="display: inline; color: rgb(10,100,80)">*</span> f <span style="display: inline; color: rgb(10,100,80)">*</span> env;
      }
    }<br><br>    <span style="display: inline; color: rgb(0,100,0)">gl_FragColor</span> <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(10,0,130)">vec4</span>(l, r, <span style="display: inline; color: rgb(130,0,0)">0.</span>, <span style="display: inline; color: rgb(130,0,0)">0.</span>);
  }
</pre>
<div style="text-align: center; color: inherit; font-size: inherit;"><p>
          <audio controls>
            <source src="audio/fsynth_lpf_mod.ogg" type="audio/ogg">
          </audio>
        </p></div>
The timbre is a bit softer, if you increase the modulation frequency, some nice sounds can be made.
<br>
<a id="subsubsec6_12_2"></a><br><br><strong>6.12.2. High-pass filter (HPF), Band-pass filter and Band-reject filter</strong><br><br>
Now that we have made a low-pass filter, we can build all the other filters easily:
<pre style="color: inherit; font-size: inherit; background-color: rgb(230,235,220); width: 600px;">
  <span style="display: inline; color: rgb(10,0,130)">float</span> adsr(<span style="display: inline; color: rgb(10,0,130)">float</span> t, <span style="display: inline; color: rgb(10,0,130)">vec4</span> v, <span style="display: inline; color: rgb(10,0,130)">float</span> s) {
    v.xyw <span style="display: inline; color: rgb(10,100,80)">=</span> max(<span style="display: inline; color: rgb(10,0,130)">vec3</span>(<span style="display: inline; color: rgb(130,0,0)">2.2</span>e<span style="display: inline; color: rgb(10,100,80)">-</span><span style="display: inline; color: rgb(130,0,130)">05</span>), v.xyw);
    <span style="display: inline; color: rgb(10,0,130)">float</span> ta <span style="display: inline; color: rgb(10,100,80)">=</span> t<span style="display: inline; color: rgb(10,100,80)">/</span>v.x;
    <span style="display: inline; color: rgb(10,0,130)">float</span> td <span style="display: inline; color: rgb(10,100,80)">=</span> max(s, <span style="display: inline; color: rgb(130,0,0)">1.0</span><span style="display: inline; color: rgb(10,100,80)">-</span>(t<span style="display: inline; color: rgb(10,100,80)">-</span>v.x)<span style="display: inline; color: rgb(10,100,80)">*</span>(<span style="display: inline; color: rgb(130,0,0)">1.0</span><span style="display: inline; color: rgb(10,100,80)">-</span>s)<span style="display: inline; color: rgb(10,100,80)">/</span>v.y);
    <span style="display: inline; color: rgb(10,0,130)">float</span> tr <span style="display: inline; color: rgb(10,100,80)">=</span> (<span style="display: inline; color: rgb(130,0,0)">1.0</span> <span style="display: inline; color: rgb(10,100,80)">-</span> max(<span style="display: inline; color: rgb(130,0,0)">0.0</span>,t<span style="display: inline; color: rgb(10,100,80)">-</span>(v.x<span style="display: inline; color: rgb(10,100,80)">+</span>v.y<span style="display: inline; color: rgb(10,100,80)">+</span>v.z))<span style="display: inline; color: rgb(10,100,80)">/</span>v.w);
    <span style="display: inline; color: rgb(10,0,130)">return</span> max(<span style="display: inline; color: rgb(130,0,0)">0.0</span>, min(ta, tr<span style="display: inline; color: rgb(10,100,80)">*</span>td));
  }<br><br>  <span style="display: inline; color: rgb(10,0,130)">float</span> lpf(<span style="display: inline; color: rgb(10,0,130)">float</span> x, <span style="display: inline; color: rgb(10,0,130)">float</span> c, <span style="display: inline; color: rgb(10,0,130)">float</span> s) {
    <span style="display: inline; color: rgb(10,0,130)">return</span> .<span style="display: inline; color: rgb(130,0,130)">5</span> <span style="display: inline; color: rgb(10,100,80)">+</span> .<span style="display: inline; color: rgb(130,0,130)">5</span> <span style="display: inline; color: rgb(10,100,80)">*</span>(<span style="display: inline; color: rgb(0,100,0)">atan</span>(s<span style="display: inline; color: rgb(10,100,80)">*</span><span style="display: inline; color: rgb(0,100,0)">cos</span>(<span style="display: inline; color: rgb(130,0,0)">3.141592653</span> <span style="display: inline; color: rgb(10,100,80)">*</span> min(max((x<span style="display: inline; color: rgb(10,100,80)">-</span>c) <span style="display: inline; color: rgb(10,100,80)">*</span> s,<span style="display: inline; color: rgb(130,0,0)">0.</span>),<span style="display: inline; color: rgb(130,0,0)">1.</span>)))<span style="display: inline; color: rgb(10,100,80)">/</span><span style="display: inline; color: rgb(0,100,0)">atan</span>(s));
  }<br><br>  <span style="display: inline; color: rgb(60,20,20)">// the high pass filter is just an inversed LPF</span>
  <span style="display: inline; color: rgb(10,0,130)">float</span> hpf(<span style="display: inline; color: rgb(10,0,130)">float</span> x, <span style="display: inline; color: rgb(10,0,130)">float</span> c, <span style="display: inline; color: rgb(10,0,130)">float</span> s) {
   	<span style="display: inline; color: rgb(10,0,130)">return</span> lpf(<span style="display: inline; color: rgb(130,0,0)">1.</span> <span style="display: inline; color: rgb(10,100,80)">-</span> x, <span style="display: inline; color: rgb(130,0,0)">1.</span> <span style="display: inline; color: rgb(10,100,80)">-</span> c, s); 
  }<br><br>  <span style="display: inline; color: rgb(60,20,20)">// a bpf is obtained by combining a lpf and hpf</span>
  <span style="display: inline; color: rgb(10,0,130)">float</span> bpf(<span style="display: inline; color: rgb(10,0,130)">float</span> x, <span style="display: inline; color: rgb(10,0,130)">float</span> c, <span style="display: inline; color: rgb(10,0,130)">float</span> s) {
    <span style="display: inline; color: rgb(10,0,130)">return</span> lpf(x, c, s) <span style="display: inline; color: rgb(10,100,80)">*</span> hpf(x, c, s);
  }<br><br>  <span style="display: inline; color: rgb(60,20,20)">// band-reject</span>
  <span style="display: inline; color: rgb(10,0,130)">float</span> brf(<span style="display: inline; color: rgb(10,0,130)">float</span> x, <span style="display: inline; color: rgb(10,0,130)">float</span> c, <span style="display: inline; color: rgb(10,0,130)">float</span> s) {
    <span style="display: inline; color: rgb(10,0,130)">return</span> (<span style="display: inline; color: rgb(130,0,0)">1.</span> <span style="display: inline; color: rgb(10,100,80)">-</span> lpf(x, c, s)) <span style="display: inline; color: rgb(10,100,80)">+</span> (<span style="display: inline; color: rgb(130,0,0)">1.</span> <span style="display: inline; color: rgb(10,100,80)">-</span> hpf(x, c, s));
  }<br><br>  <span style="display: inline; color: rgb(10,0,130)">void</span> main () {
    <span style="display: inline; color: rgb(10,0,130)">vec2</span> uv <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(0,100,0)">gl_FragCoord</span>.xy <span style="display: inline; color: rgb(10,100,80)">/</span> <span style="display: inline; color: rgb(0,100,100)">resolution</span>.xy;<br><br>    <span style="display: inline; color: rgb(10,0,130)">float</span> l <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;
    <span style="display: inline; color: rgb(10,0,130)">float</span> r <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;<br><br>    <span style="display: inline; color: rgb(10,0,130)">const</span> <span style="display: inline; color: rgb(10,0,130)">float</span> harmonics <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">16.</span>;<br><br>    <span style="display: inline; color: rgb(10,0,130)">for</span> (<span style="display: inline; color: rgb(10,0,130)">int</span> k <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,130)">0</span>; k <span style="display: inline; color: rgb(10,100,80)">&lt;</span> <span style="display: inline; color: rgb(130,0,130)">8</span>; k <span style="display: inline; color: rgb(10,100,80)">+=</span> <span style="display: inline; color: rgb(130,0,130)">1</span>) {
      <span style="display: inline; color: rgb(10,0,130)">vec4</span> data <span style="display: inline; color: rgb(10,100,80)">=</span> keyboard[k];<br><br>      <span style="display: inline; color: rgb(10,0,130)">float</span> kfrq <span style="display: inline; color: rgb(10,100,80)">=</span> data.x;
      <span style="display: inline; color: rgb(10,0,130)">float</span> kvel <span style="display: inline; color: rgb(10,100,80)">=</span> data.y;
      <span style="display: inline; color: rgb(10,0,130)">float</span> ktim <span style="display: inline; color: rgb(10,100,80)">=</span> data.z;
      <span style="display: inline; color: rgb(10,0,130)">float</span> kchn <span style="display: inline; color: rgb(10,100,80)">=</span> data.w;<br><br>      <span style="display: inline; color: rgb(10,0,130)">if</span> (kfrq <span style="display: inline; color: rgb(10,100,80)">==</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>) {
       	break; 
      }<br><br>      <span style="display: inline; color: rgb(10,0,130)">float</span> cutoff <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(0,100,100)">htoy</span>(kfrq) <span style="display: inline; color: rgb(10,100,80)">/</span> <span style="display: inline; color: rgb(0,100,100)">resolution</span>.y;<br><br>      <span style="display: inline; color: rgb(10,0,130)">float</span> slope <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">3.</span> <span style="display: inline; color: rgb(10,100,80)">+</span> <span style="display: inline; color: rgb(0,100,0)">sin</span>(ktim <span style="display: inline; color: rgb(10,100,80)">*</span> <span style="display: inline; color: rgb(130,0,0)">4.</span>);<br><br>      <span style="display: inline; color: rgb(60,20,20)">// we compute our filters</span>
      <span style="display: inline; color: rgb(60,20,20)">// note that we modulate the cutoff parameter</span>
      <span style="display: inline; color: rgb(60,20,20)">// to show how the filters behave</span>
      <span style="display: inline; color: rgb(10,0,130)">float</span> fhp <span style="display: inline; color: rgb(10,100,80)">=</span> hpf(uv.y, cutoff <span style="display: inline; color: rgb(10,100,80)">+</span> <span style="display: inline; color: rgb(0,100,0)">sin</span>(ktim <span style="display: inline; color: rgb(10,100,80)">*</span> <span style="display: inline; color: rgb(130,0,0)">1.25</span>) <span style="display: inline; color: rgb(10,100,80)">/</span> <span style="display: inline; color: rgb(130,0,0)">2.</span>, slope);
      <span style="display: inline; color: rgb(10,0,130)">float</span> fbp <span style="display: inline; color: rgb(10,100,80)">=</span> bpf(uv.y, cutoff <span style="display: inline; color: rgb(10,100,80)">+</span> <span style="display: inline; color: rgb(0,100,0)">sin</span>((ktim <span style="display: inline; color: rgb(10,100,80)">-</span> <span style="display: inline; color: rgb(130,0,0)">1.</span>) <span style="display: inline; color: rgb(10,100,80)">*</span> <span style="display: inline; color: rgb(130,0,0)">1.25</span>) <span style="display: inline; color: rgb(10,100,80)">/</span> <span style="display: inline; color: rgb(130,0,0)">2.</span>, slope <span style="display: inline; color: rgb(10,100,80)">*</span> <span style="display: inline; color: rgb(130,0,0)">1.25</span>);
      <span style="display: inline; color: rgb(10,0,130)">float</span> fbr <span style="display: inline; color: rgb(10,100,80)">=</span> brf(uv.y, cutoff <span style="display: inline; color: rgb(10,100,80)">+</span> <span style="display: inline; color: rgb(0,100,0)">sin</span>((ktim <span style="display: inline; color: rgb(10,100,80)">-</span> <span style="display: inline; color: rgb(130,0,0)">2.</span>) <span style="display: inline; color: rgb(10,100,80)">*</span> <span style="display: inline; color: rgb(130,0,0)">1.25</span>) <span style="display: inline; color: rgb(10,100,80)">/</span> <span style="display: inline; color: rgb(130,0,0)">2.</span>, slope <span style="display: inline; color: rgb(10,100,80)">*</span> <span style="display: inline; color: rgb(130,0,0)">1.5</span>);<br><br>      <span style="display: inline; color: rgb(10,0,130)">float</span> attack <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.5</span>;
      <span style="display: inline; color: rgb(10,0,130)">float</span> decay <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.5</span>;
      <span style="display: inline; color: rgb(10,0,130)">float</span> sustain <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;
      <span style="display: inline; color: rgb(10,0,130)">float</span> release <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.25</span>;
      <span style="display: inline; color: rgb(10,0,130)">float</span> dec_amp <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;<br><br>      <span style="display: inline; color: rgb(60,20,20)">// note how we offset the keyboard time</span>
      <span style="display: inline; color: rgb(60,20,20)">// of the total amount of time the envelope will take</span>
      <span style="display: inline; color: rgb(60,20,20)">// so that our sounds start when the previous end</span>
      <span style="display: inline; color: rgb(10,0,130)">float</span> env<span style="display: inline; color: rgb(130,0,130)">1</span> <span style="display: inline; color: rgb(10,100,80)">=</span> kvel <span style="display: inline; color: rgb(10,100,80)">*</span> adsr(ktim, <span style="display: inline; color: rgb(10,0,130)">vec4</span>(attack, decay, sustain, release), dec_amp);
      <span style="display: inline; color: rgb(10,0,130)">float</span> env<span style="display: inline; color: rgb(130,0,130)">2</span> <span style="display: inline; color: rgb(10,100,80)">=</span> kvel <span style="display: inline; color: rgb(10,100,80)">*</span> adsr(ktim <span style="display: inline; color: rgb(10,100,80)">-</span> <span style="display: inline; color: rgb(130,0,0)">1.</span>, <span style="display: inline; color: rgb(10,0,130)">vec4</span>(attack, decay, sustain, release), dec_amp);
      <span style="display: inline; color: rgb(10,0,130)">float</span> env<span style="display: inline; color: rgb(130,0,130)">3</span> <span style="display: inline; color: rgb(10,100,80)">=</span> kvel <span style="display: inline; color: rgb(10,100,80)">*</span> adsr(ktim <span style="display: inline; color: rgb(10,100,80)">-</span> <span style="display: inline; color: rgb(130,0,0)">2.</span>, <span style="display: inline; color: rgb(10,0,130)">vec4</span>(attack, decay, sustain, release), dec_amp);<br><br>      <span style="display: inline; color: rgb(10,0,130)">for</span> (<span style="display: inline; color: rgb(10,0,130)">float</span> i <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span>; i <span style="display: inline; color: rgb(10,100,80)">&lt;</span> harmonics; i <span style="display: inline; color: rgb(10,100,80)">+=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span>) {
        <span style="display: inline; color: rgb(10,0,130)">float</span> f <span style="display: inline; color: rgb(10,100,80)">=</span> kfrq <span style="display: inline; color: rgb(10,100,80)">*</span> i;<br><br>        <span style="display: inline; color: rgb(60,20,20)">// we build three sounds offseted by the envelope</span>
        <span style="display: inline; color: rgb(60,20,20)">// with each filters assigned</span>
        l <span style="display: inline; color: rgb(10,100,80)">+=</span> fline(f) <span style="display: inline; color: rgb(10,100,80)">*</span> fhp <span style="display: inline; color: rgb(10,100,80)">*</span> env<span style="display: inline; color: rgb(130,0,130)">1</span>;
        r <span style="display: inline; color: rgb(10,100,80)">+=</span> fline(f) <span style="display: inline; color: rgb(10,100,80)">*</span> fhp <span style="display: inline; color: rgb(10,100,80)">*</span> env<span style="display: inline; color: rgb(130,0,130)">1</span>;<br><br>        l <span style="display: inline; color: rgb(10,100,80)">+=</span> fline(f) <span style="display: inline; color: rgb(10,100,80)">*</span> fbp <span style="display: inline; color: rgb(10,100,80)">*</span> env<span style="display: inline; color: rgb(130,0,130)">2</span>;
        r <span style="display: inline; color: rgb(10,100,80)">+=</span> fline(f) <span style="display: inline; color: rgb(10,100,80)">*</span> fbp <span style="display: inline; color: rgb(10,100,80)">*</span> env<span style="display: inline; color: rgb(130,0,130)">2</span>;<br><br>        l <span style="display: inline; color: rgb(10,100,80)">+=</span> fline(f) <span style="display: inline; color: rgb(10,100,80)">*</span> fbr <span style="display: inline; color: rgb(10,100,80)">*</span> env<span style="display: inline; color: rgb(130,0,130)">3</span>;
        r <span style="display: inline; color: rgb(10,100,80)">+=</span> fline(f) <span style="display: inline; color: rgb(10,100,80)">*</span> fbr <span style="display: inline; color: rgb(10,100,80)">*</span> env<span style="display: inline; color: rgb(130,0,130)">3</span>;
      }
    }<br><br>    <span style="display: inline; color: rgb(0,100,0)">gl_FragColor</span> <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(10,0,130)">vec4</span>(l, r, <span style="display: inline; color: rgb(130,0,0)">0.</span>, <span style="display: inline; color: rgb(130,0,0)">0.</span>);
  }
</pre>
<div style="text-align: center; color: inherit; font-size: inherit;"><p>
          <audio controls>
            <source src="audio/fsynth_filters.ogg" type="audio/ogg">
          </audio>
        </p></div>
The given functions are not set in stone, you can change them, those functions have some drawbacks actually, notably the fact that they don't have a resonance parameter and that the filters cutoff/slope need to be adjusted for HPF/BPF/BRF because the attenuation is not per octaves, we will see next some other functions which will adress these issues.<br><br><br>
<a id="subsec6_13"></a><span style="font-size: 120%;"><strong>6.13. Timbral possibilities</strong></span><br><br>
A neat thing that can be done with Fragment is modulating the parameters you want with the current horizontal or vertical position, the canvas will then show you many timbral possibilities that you can chose to listen to by adding and positioning slices on the canvas, you can also modulate the horizontal position to move between timbral possibilities.<br><br>By adding many slices at different positions, you can build very complex sounds and explore without having to write code.<br><br><pre style="color: inherit; font-size: inherit; background-color: rgb(230,235,220); width: 600px;">
  <span style="display: inline; color: rgb(10,0,130)">float</span> adsr(<span style="display: inline; color: rgb(10,0,130)">float</span> t, <span style="display: inline; color: rgb(10,0,130)">vec4</span> v, <span style="display: inline; color: rgb(10,0,130)">float</span> s) {
    v.xyw <span style="display: inline; color: rgb(10,100,80)">=</span> max(<span style="display: inline; color: rgb(10,0,130)">vec3</span>(<span style="display: inline; color: rgb(130,0,0)">2.2</span>e<span style="display: inline; color: rgb(10,100,80)">-</span><span style="display: inline; color: rgb(130,0,130)">05</span>), v.xyw);
    <span style="display: inline; color: rgb(10,0,130)">float</span> ta <span style="display: inline; color: rgb(10,100,80)">=</span> t<span style="display: inline; color: rgb(10,100,80)">/</span>v.x;
    <span style="display: inline; color: rgb(10,0,130)">float</span> td <span style="display: inline; color: rgb(10,100,80)">=</span> max(s, <span style="display: inline; color: rgb(130,0,0)">1.0</span><span style="display: inline; color: rgb(10,100,80)">-</span>(t<span style="display: inline; color: rgb(10,100,80)">-</span>v.x)<span style="display: inline; color: rgb(10,100,80)">*</span>(<span style="display: inline; color: rgb(130,0,0)">1.0</span><span style="display: inline; color: rgb(10,100,80)">-</span>s)<span style="display: inline; color: rgb(10,100,80)">/</span>v.y);
    <span style="display: inline; color: rgb(10,0,130)">float</span> tr <span style="display: inline; color: rgb(10,100,80)">=</span> (<span style="display: inline; color: rgb(130,0,0)">1.0</span> <span style="display: inline; color: rgb(10,100,80)">-</span> max(<span style="display: inline; color: rgb(130,0,0)">0.0</span>,t<span style="display: inline; color: rgb(10,100,80)">-</span>(v.x<span style="display: inline; color: rgb(10,100,80)">+</span>v.y<span style="display: inline; color: rgb(10,100,80)">+</span>v.z))<span style="display: inline; color: rgb(10,100,80)">/</span>v.w);
    <span style="display: inline; color: rgb(10,0,130)">return</span> max(<span style="display: inline; color: rgb(130,0,0)">0.0</span>, min(ta, tr<span style="display: inline; color: rgb(10,100,80)">*</span>td));
  }<br><br>  <span style="display: inline; color: rgb(10,0,130)">float</span> lpf(<span style="display: inline; color: rgb(10,0,130)">float</span> x, <span style="display: inline; color: rgb(10,0,130)">float</span> c, <span style="display: inline; color: rgb(10,0,130)">float</span> s) {
    <span style="display: inline; color: rgb(10,0,130)">return</span> .<span style="display: inline; color: rgb(130,0,130)">5</span> <span style="display: inline; color: rgb(10,100,80)">+</span> .<span style="display: inline; color: rgb(130,0,130)">5</span> <span style="display: inline; color: rgb(10,100,80)">*</span>(<span style="display: inline; color: rgb(0,100,0)">atan</span>(s<span style="display: inline; color: rgb(10,100,80)">*</span><span style="display: inline; color: rgb(0,100,0)">cos</span>(<span style="display: inline; color: rgb(130,0,0)">3.141592653</span> <span style="display: inline; color: rgb(10,100,80)">*</span> min(max((x<span style="display: inline; color: rgb(10,100,80)">-</span>c) <span style="display: inline; color: rgb(10,100,80)">*</span> s,<span style="display: inline; color: rgb(130,0,0)">0.</span>),<span style="display: inline; color: rgb(130,0,0)">1.</span>)))<span style="display: inline; color: rgb(10,100,80)">/</span><span style="display: inline; color: rgb(0,100,0)">atan</span>(s));
  }<br><br>  <span style="display: inline; color: rgb(10,0,130)">void</span> main () {
    <span style="display: inline; color: rgb(10,0,130)">vec2</span> uv <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(0,100,0)">gl_FragCoord</span>.xy <span style="display: inline; color: rgb(10,100,80)">/</span> <span style="display: inline; color: rgb(0,100,100)">resolution</span>.xy;<br><br>    <span style="display: inline; color: rgb(10,0,130)">float</span> l <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;
    <span style="display: inline; color: rgb(10,0,130)">float</span> r <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;<br><br>    <span style="display: inline; color: rgb(10,0,130)">const</span> <span style="display: inline; color: rgb(10,0,130)">float</span> harmonics <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">16.</span>;<br><br>    <span style="display: inline; color: rgb(10,0,130)">for</span> (<span style="display: inline; color: rgb(10,0,130)">int</span> k <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,130)">0</span>; k <span style="display: inline; color: rgb(10,100,80)">&lt;</span> <span style="display: inline; color: rgb(130,0,130)">8</span>; k <span style="display: inline; color: rgb(10,100,80)">+=</span> <span style="display: inline; color: rgb(130,0,130)">1</span>) {
      <span style="display: inline; color: rgb(10,0,130)">vec4</span> data <span style="display: inline; color: rgb(10,100,80)">=</span> keyboard[k];<br><br>      <span style="display: inline; color: rgb(10,0,130)">float</span> kfrq <span style="display: inline; color: rgb(10,100,80)">=</span> data.x;
      <span style="display: inline; color: rgb(10,0,130)">float</span> kvel <span style="display: inline; color: rgb(10,100,80)">=</span> data.y;
      <span style="display: inline; color: rgb(10,0,130)">float</span> ktim <span style="display: inline; color: rgb(10,100,80)">=</span> data.z;
      <span style="display: inline; color: rgb(10,0,130)">float</span> kchn <span style="display: inline; color: rgb(10,100,80)">=</span> data.w;<br><br>      <span style="display: inline; color: rgb(10,0,130)">if</span> (kfrq <span style="display: inline; color: rgb(10,100,80)">==</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>) {
       	break; 
      }<br><br>      <span style="display: inline; color: rgb(10,0,130)">float</span> cutoff <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(0,100,100)">htoy</span>(kfrq) <span style="display: inline; color: rgb(10,100,80)">/</span> <span style="display: inline; color: rgb(0,100,100)">resolution</span>.y;
      <span style="display: inline; color: rgb(10,0,130)">float</span> slope <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">3.</span> <span style="display: inline; color: rgb(10,100,80)">+</span> <span style="display: inline; color: rgb(0,100,0)">sin</span>(ktim <span style="display: inline; color: rgb(10,100,80)">*</span> <span style="display: inline; color: rgb(130,0,0)">16.</span>) <span style="display: inline; color: rgb(10,100,80)">/</span> <span style="display: inline; color: rgb(130,0,0)">4.</span>;<br><br>      <span style="display: inline; color: rgb(10,0,130)">for</span> (<span style="display: inline; color: rgb(10,0,130)">float</span> i <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span>; i <span style="display: inline; color: rgb(10,100,80)">&lt;</span> harmonics; i <span style="display: inline; color: rgb(10,100,80)">+=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span>) {
        <span style="display: inline; color: rgb(60,20,20)">// notice how we multiply the cutoff by the horizontal position</span>
        <span style="display: inline; color: rgb(10,0,130)">float</span> f <span style="display: inline; color: rgb(10,100,80)">=</span> lpf(uv.y, cutoff <span style="display: inline; color: rgb(10,100,80)">*</span> uv.x, slope);<br><br>        <span style="display: inline; color: rgb(10,0,130)">float</span> attack <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.05</span>;
        <span style="display: inline; color: rgb(10,0,130)">float</span> decay <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.6</span>;
        <span style="display: inline; color: rgb(10,0,130)">float</span> sustain <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;
        <span style="display: inline; color: rgb(10,0,130)">float</span> release <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.25</span>;
        <span style="display: inline; color: rgb(10,0,130)">float</span> dec_amp <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;
        <span style="display: inline; color: rgb(10,0,130)">float</span> env <span style="display: inline; color: rgb(10,100,80)">=</span> kvel <span style="display: inline; color: rgb(10,100,80)">*</span> adsr(ktim, <span style="display: inline; color: rgb(10,0,130)">vec4</span>(attack, decay, sustain, release), dec_amp);<br><br>        l <span style="display: inline; color: rgb(10,100,80)">+=</span> fline(kfrq <span style="display: inline; color: rgb(10,100,80)">*</span> i) <span style="display: inline; color: rgb(10,100,80)">*</span> f <span style="display: inline; color: rgb(10,100,80)">*</span> env;
        r <span style="display: inline; color: rgb(10,100,80)">+=</span> fline(kfrq <span style="display: inline; color: rgb(10,100,80)">*</span> i) <span style="display: inline; color: rgb(10,100,80)">*</span> f <span style="display: inline; color: rgb(10,100,80)">*</span> env;
      }
    }<br><br>    <span style="display: inline; color: rgb(0,100,0)">gl_FragColor</span> <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(10,0,130)">vec4</span>(l, r, <span style="display: inline; color: rgb(130,0,0)">0.</span>, <span style="display: inline; color: rgb(130,0,0)">0.</span>);
  }
</pre>
<a href="images/possibilities.png"><div style="text-align: center; color: inherit; font-size: inherit;"><p><img src="images/possibilities.png" width="522"></p></div></a>
<div style="text-align: center; color: inherit; font-size: inherit;"><p>Timbral possibilities along the X axis related to a LPF cutoff parameter</p></div>
<br>
<a id="subsec6_14"></a><span style="font-size: 120%;"><strong>6.14. Delay effect</strong></span><br><br>
Now that we have all the essential components of any modern synthesizers, we can do some more complex things like effects, arpgeggio, sequences, filters etc.
<pre style="color: inherit; font-size: inherit; background-color: rgb(230,235,220); width: 600px;">
Coming soon...
</pre><br><br><br>
<a id="subsec6_15"></a><span style="font-size: 120%;"><strong>6.15. Sequence</strong></span><br><br>
We will see in this section how to do a 16 or N steps sequences with Fragment, we will use the <a rel="tag" href="#uniformsdialog">uniforms dialog</a> to define an array of values which will hold the frequency data of our sequence.<br><br>You can do that by opening the <a rel="tag" href="#uniformsdialog">uniforms dialog</a> and then adding an array of uniforms named <strong>sequence</strong> as pictured below:
<a href="images/sequence.png"><div style="text-align: center; color: inherit; font-size: inherit;"><p><img src="images/sequence.png" width="235"></p></div></a>
<br>
Many values should appear now in the uniforms dialog, you can change the frequency value for each steps with your keyboard, mouse or by assigning a MIDI control to each steps.<br><br>Here is the code to play a sequence automatically:
<pre style="color: inherit; font-size: inherit; background-color: rgb(230,235,220); width: 600px;">
<span style="display: inline; color: rgb(60,20,20)">// we define the PI constant</span>
<span style="display: inline; color: rgb(60,20,20)">// note: the "#define" keyword cannot start on the very first line</span>
<span style="display: inline; color: rgb(0,100,0)">#define</span> pi <span style="display: inline; color: rgb(130,0,0)">3.141592653</span><br><br><span style="display: inline; color: rgb(10,0,130)">float</span> impulse(<span style="display: inline; color: rgb(10,0,130)">float</span> k, <span style="display: inline; color: rgb(10,0,130)">float</span> x) {
    <span style="display: inline; color: rgb(10,0,130)">float</span> h <span style="display: inline; color: rgb(10,100,80)">=</span> k <span style="display: inline; color: rgb(10,100,80)">*</span> x;
    <span style="display: inline; color: rgb(10,0,130)">return</span> h <span style="display: inline; color: rgb(10,100,80)">*</span> <span style="display: inline; color: rgb(0,100,0)">exp</span>(<span style="display: inline; color: rgb(130,0,0)">1.0</span> <span style="display: inline; color: rgb(10,100,80)">-</span> h);
}<br><br><span style="display: inline; color: rgb(10,0,130)">void</span> main () {
    <span style="display: inline; color: rgb(10,0,130)">float</span> l <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;
    <span style="display: inline; color: rgb(10,0,130)">float</span> r <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;
    <span style="display: inline; color: rgb(10,0,130)">float</span> base_frequency <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">440.</span>;<br><br>    <span style="display: inline; color: rgb(60,20,20)">// we just redefine globalTime for convenience</span>
    <span style="display: inline; color: rgb(60,20,20)">// globalTime is a pre-defined Fragment uniform</span>
    <span style="display: inline; color: rgb(60,20,20)">// which hold the time since Fragment started to play</span>
    <span style="display: inline; color: rgb(60,20,20)">// you can "rewind" it by clicking on the corresponding toolbar button</span>
    <span style="display: inline; color: rgb(10,0,130)">float</span> time <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(0,100,100)">globalTime</span>;<br><br>    <span style="display: inline; color: rgb(60,20,20)">// increase the number of harmonics so we get a richer sound</span>
    <span style="display: inline; color: rgb(10,0,130)">const</span> <span style="display: inline; color: rgb(10,0,130)">float</span> harmonics <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">16.</span>;<br><br>    <span style="display: inline; color: rgb(60,20,20)">// we will override "keyboard" because GLSL</span>
    <span style="display: inline; color: rgb(60,20,20)">// does not permit us to assign by index dynamically</span>
    <span style="display: inline; color: rgb(60,20,20)">// we will have 8 notes polyphony (copied from "keyboard" + the sequence)</span>
    <span style="display: inline; color: rgb(10,0,130)">vec4</span> notes[<span style="display: inline; color: rgb(130,0,130)">9</span>];
  	
    <span style="display: inline; color: rgb(60,20,20)">// our sequence have 16 steps</span>
    <span style="display: inline; color: rgb(10,0,130)">float</span> seq_length <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">16.</span>;<br><br>    <span style="display: inline; color: rgb(60,20,20)">// we use the "mod" function with the length of the sequence</span>
    <span style="display: inline; color: rgb(60,20,20)">// this play our sequence over and over, 4 notes per seconds</span>
    <span style="display: inline; color: rgb(10,0,130)">int</span> seq_index <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(10,0,130)">int</span>(<span style="display: inline; color: rgb(0,100,0)">floor</span>(<span style="display: inline; color: rgb(0,100,0)">mod</span>(time <span style="display: inline; color: rgb(10,100,80)">*</span> <span style="display: inline; color: rgb(130,0,0)">4.</span>, seq_length)));<br><br>    <span style="display: inline; color: rgb(60,20,20)">// this is a GLSL trick to get the current step frequency</span>
    <span style="display: inline; color: rgb(60,20,20)">// we do that because "sequence[seq_index]" is not accepted</span>
    <span style="display: inline; color: rgb(60,20,20)">// this is a limitation of the most compatible WebGL spec.</span>
    <span style="display: inline; color: rgb(60,20,20)">// which do not allow dynamical indexes for arrays...</span>
    <span style="display: inline; color: rgb(60,20,20)">// if your browser has support for WebGL 2, this can be</span>
    <span style="display: inline; color: rgb(60,20,20)">// MUCH simpler!</span>
    <span style="display: inline; color: rgb(10,0,130)">float</span> seq_frq <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">0.</span>;
    <span style="display: inline; color: rgb(10,0,130)">for</span> (<span style="display: inline; color: rgb(10,0,130)">int</span> k <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,130)">0</span>; k <span style="display: inline; color: rgb(10,100,80)">&lt;</span> <span style="display: inline; color: rgb(130,0,130)">16</span>; k <span style="display: inline; color: rgb(10,100,80)">+=</span> <span style="display: inline; color: rgb(130,0,130)">1</span>) {
      <span style="display: inline; color: rgb(10,0,130)">if</span> (k <span style="display: inline; color: rgb(10,100,80)">==</span> seq_index) {
        seq_frq <span style="display: inline; color: rgb(10,100,80)">=</span> sequence[k];
      }
    }<br><br>    <span style="display: inline; color: rgb(60,20,20)">// now we just copy 8 notes from the "keyboard" array</span>
    <span style="display: inline; color: rgb(60,20,20)">// which will allow us to play 8 notes at the same time</span>
    <span style="display: inline; color: rgb(60,20,20)">// with a MIDI keyboard</span>
    <span style="display: inline; color: rgb(10,0,130)">for</span> (<span style="display: inline; color: rgb(10,0,130)">int</span> k <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,130)">0</span>; k <span style="display: inline; color: rgb(10,100,80)">&lt;</span> <span style="display: inline; color: rgb(130,0,130)">8</span>; k <span style="display: inline; color: rgb(10,100,80)">+=</span> <span style="display: inline; color: rgb(130,0,130)">1</span>) {
      notes[k] <span style="display: inline; color: rgb(10,100,80)">=</span> keyboard[k];
    }<br><br>    <span style="display: inline; color: rgb(60,20,20)">// we assign the current sequence note</span>
    <span style="display: inline; color: rgb(60,20,20)">// notice how we make the note duration</span>
    <span style="display: inline; color: rgb(60,20,20)">// perfectly fit within its lifetime</span>
    <span style="display: inline; color: rgb(60,20,20)">// it goes on, hit its peak and go down</span>
    <span style="display: inline; color: rgb(60,20,20)">// before passing to the next</span>
    notes[<span style="display: inline; color: rgb(130,0,130)">7</span>] <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(10,0,130)">vec4</span>(seq_frq, <span style="display: inline; color: rgb(130,0,0)">1.</span>, <span style="display: inline; color: rgb(130,0,0)">0.5</span> <span style="display: inline; color: rgb(10,100,80)">*</span> (<span style="display: inline; color: rgb(130,0,0)">1.</span> <span style="display: inline; color: rgb(10,100,80)">+</span> <span style="display: inline; color: rgb(0,100,0)">sin</span>((pi <span style="display: inline; color: rgb(10,100,80)">*</span> <span style="display: inline; color: rgb(130,0,0)">1.5</span>) <span style="display: inline; color: rgb(10,100,80)">+</span> <span style="display: inline; color: rgb(130,0,0)">2.</span> <span style="display: inline; color: rgb(10,100,80)">*</span> pi <span style="display: inline; color: rgb(10,100,80)">*</span> time)), <span style="display: inline; color: rgb(130,0,0)">0.</span>);<br><br>    <span style="display: inline; color: rgb(60,20,20)">// we loop over our 9 notes</span>
    <span style="display: inline; color: rgb(10,0,130)">for</span> (<span style="display: inline; color: rgb(10,0,130)">int</span> k <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,130)">0</span>; k <span style="display: inline; color: rgb(10,100,80)">&lt;</span> <span style="display: inline; color: rgb(130,0,130)">9</span>; k <span style="display: inline; color: rgb(10,100,80)">+=</span> <span style="display: inline; color: rgb(130,0,130)">1</span>) {
      <span style="display: inline; color: rgb(60,20,20)">// notice that we no more use "keyboard"</span>
      <span style="display: inline; color: rgb(60,20,20)">// but our overriden "keyboard" array with our sequence within</span>
      <span style="display: inline; color: rgb(10,0,130)">vec4</span> data <span style="display: inline; color: rgb(10,100,80)">=</span> notes[k];<br><br>      <span style="display: inline; color: rgb(10,0,130)">float</span> kfrq <span style="display: inline; color: rgb(10,100,80)">=</span> data.x;
      <span style="display: inline; color: rgb(10,0,130)">float</span> kvel <span style="display: inline; color: rgb(10,100,80)">=</span> data.y;
      <span style="display: inline; color: rgb(10,0,130)">float</span> ktim <span style="display: inline; color: rgb(10,100,80)">=</span> data.z;
      <span style="display: inline; color: rgb(10,0,130)">float</span> kchn <span style="display: inline; color: rgb(10,100,80)">=</span> data.w;<br><br>      <span style="display: inline; color: rgb(10,0,130)">float</span> env <span style="display: inline; color: rgb(10,100,80)">=</span> kvel <span style="display: inline; color: rgb(10,100,80)">*</span> impulse(<span style="display: inline; color: rgb(130,0,0)">1.</span>, ktim);<br><br>      <span style="display: inline; color: rgb(10,0,130)">for</span> (<span style="display: inline; color: rgb(10,0,130)">float</span> i <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span>; i <span style="display: inline; color: rgb(10,100,80)">&lt;</span> harmonics; i <span style="display: inline; color: rgb(10,100,80)">+=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span>) {
        <span style="display: inline; color: rgb(10,0,130)">float</span> a <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(130,0,0)">1.</span> <span style="display: inline; color: rgb(10,100,80)">/</span> <span style="display: inline; color: rgb(0,100,0)">pow</span>(i, <span style="display: inline; color: rgb(130,0,0)">1.95</span>);<br><br>        l <span style="display: inline; color: rgb(10,100,80)">+=</span> fline(kfrq <span style="display: inline; color: rgb(10,100,80)">*</span> i) <span style="display: inline; color: rgb(10,100,80)">*</span> a <span style="display: inline; color: rgb(10,100,80)">*</span> env;
        r <span style="display: inline; color: rgb(10,100,80)">+=</span> fline(kfrq <span style="display: inline; color: rgb(10,100,80)">*</span> i) <span style="display: inline; color: rgb(10,100,80)">*</span> a <span style="display: inline; color: rgb(10,100,80)">*</span> env;
      }
    }<br><br>    <span style="display: inline; color: rgb(0,100,0)">gl_FragColor</span> <span style="display: inline; color: rgb(10,100,80)">=</span> <span style="display: inline; color: rgb(10,0,130)">vec4</span>(l, r, <span style="display: inline; color: rgb(130,0,0)">0.</span>, <span style="display: inline; color: rgb(130,0,0)">0.</span>);
  }
</pre>
<div style="text-align: center; color: inherit; font-size: inherit;"><p>
          <audio controls>
            <source src="audio/fsynth_sequence.ogg" type="audio/ogg">
          </audio>
        </p></div>
You should hear a sequence of notes which you can play along with a MIDI keyboard.<br><br>An autonomous sequence is relatively easy and can also be done by using the <strong>mod</strong> function or by simpler means.<br><br>We strongly recommend that peoples use Fragment with a MIDI sequencer such as <a href="https://www.lmms.io">LMMS</a>, <a href="https://www.iannix.org">IanniX</a>, <a href="https://www.renoise.com/">Renoise</a>, <a href="http://muse-sequencer.org">MusE</a> or any other MIDI capable sequencers, sequences can be done very easily within a sequencer and many effects can be added to the audio output.<br><br><br>
<a id="subsec6_16"></a><span style="font-size: 120%;"><strong>6.16. Note on globalTime</strong></span><br><br>
The global time is one of the most important pre-defined variable in Fragment, it is a playback time that increase continually as soon as you hit the play button on the toolbar, it can only be reset or paused by using the corresponding toolbar button, the global time is a precise clock which can be used to trigger events and dynamically alter the visuals.
<br>
<a id="sec7"></a><br><br><span style="font-size: 120%;"><span style="font-size: 120%;"><strong>7. Contributing</strong></span></span><br><br>
Fragment is a free and open source software released under the term of the BSDv2 license.<br><br>Any contributions from the documentation to the synthesis engine are welcome!<br><br>The source code is available on <a href="https://github.com/grz0zrg/fsynth">GitHub</a>.<br><br><a rel="tag" href="#fas">FAS</a> source code is also available on <a href="https://github.com/grz0zrg/fas">GitHub</a>.
<br>
<a id="sec8"></a><br><br><span style="font-size: 120%;"><span style="font-size: 120%;"><strong>8. Links</strong></span></span><br><br>
<span><ul>
	<li> <a href="https://www.fsynth.com">Fragment Synthesizer website</a>
	<li> <a href="https://quiet.fsynth.com">Fragment Synthesizer forum</a>
	<li> <a href="https://github.com/grz0zrg/fsynth">Fragment source code</a>
	<li> <a href="https://github.com/grz0zrg/fas">FAS source code</a>
	<li> <a href="https://www.facebook.com/fsynth/">Facebook</a>
	<li> <a href="https://www.youtube.com/channel/UC2CJFT1_ybPcTNlT6bVG0WQ">YouTube</a>
	<li> <a href="https://twitter.com/fragmentsynth">Twitter</a>
	<li> <a href="https://soundcloud.com/fsynth/">SoundCloud</a></ul></span>
<a id="sec9"></a><br><br><span style="font-size: 120%;"><span style="font-size: 120%;"><strong>9. Credits</strong></span></span><br><br>
<span><ul>
	<li> Testing: <span><ul><li> Franz Khrum</ul></span>
	<li> Papers: <span><ul>
		<li> <a href="http://www.dspguide.com">The Scientist and Engineer's Guide to Digital Signal Processing</a>
		<li> <a href="http://www.synthesizer-cookbook.com">Welsh's Synthesizer Cookbook</a>
		<li> <a href="http://www-evasion.imag.fr/Membres/Fabrice.Neyret/demos/DesmosGraph/indexImages.html">Fabrice Neyret Desmos page</a>
	</ul></span>
	<li> Ideas: <span><ul>
		<li> <a href="http://www.warmplace.ru/soft/ans/">Virtual ANS</a>
		<li> <a href="https://www.shadertoy.com/">ShaderToy</a></ul></span>
	<li> Tools: <span><ul>
		<li> <a href="http://redmine.anubis-language.com/">The Anubis programming language</a>
		<li> <a href="https://www.desmos.com">desmos</a>
		<li> <a href="http://www.jedit.org/">jEdit</a>
		<li> <a href="https://www.inkscape.org">Inkscape</a>
		<li> <a href="https://www.geogebra.org">Geogebra</a>
		<li> <a href="https://www.gimp.org">The GIMP</a>
		<li> <a href="https://kdenlive.org">KDEnlive</a>
		<li> <a href="http://www.maartenbaert.be/simplescreenrecorder/">SimpleScreenRecorder</a>
		<li> <a href="http://liblfds.org">libflds</a>
		<li> <a href="http://www.portaudio.com">portaudio</a>
		<li> <a href="https://libwebsockets.org">libwebsockets</a>
		<li> <a href="http://brackets.io/">Brackets</a>
		<li> <a href="http://fa2png.io/">fa2png</a>
		<li> <a href="http://fontawesome.io/">FontAwesome</a>
		<li> <a href="http://codemirror.net/">CodeMirror</a>
		<li> <a href="https://github.com/share/sharedb/">ShareDB</a>
		<li> <a href="https://www.npmjs.com/package/live-server">live-server</a>
		<li> <a href="https://necolas.github.io/normalize.css/">Normalize</a>
		<li> <a href="http://getskeleton.com/">Skeleton</a>
		<li> <a href="https://nodejs.org/en/">NodeJS</a>
		<li> <a href="https://www.nginx.com/">NGINX</a>
		<li> <a href="http://flarum.org/">Flarum</a>
		<li> <a href="https://github.com/Unitech/pm2">pm2</a>
		<li> <a href="https://sourceforge.net/projects/hotshot">HotShots</a>
		<li> <a href="https://www.mongodb.com/">MongoDB</a>
		<li> <a href="https://redis.io/">Redis</a>
		<li> <a href="https://github.com/winstonjs/winston">Winston</a>
		<li> <a href="http://expressjs.com/">Express</a>
		<li> <a href="https://github.com/strongloop/strong-cluster-control">strong-cluster-control</a></ul></span>
	<li> Data: <span><ul>
		<li> <a href="http://www.texturemate.com">Bundled brushes</a>
		</ul></span></ul></span><br><br><br>
<div style="text-align: center; color: inherit; font-size: inherit;"><p><span style="font-size: 120%;"><span style="font-size: 120%;"><span style="font-size: 120%;"><span style="font-size: 120%;">T<span style="display: inline; color: rgb(150,0,0)"><em>h</em></span><span style="display: inline; color: rgb(10,0,130)"><sup>a</sup></span><span style="display: inline; color: rgb(100,100,0)"><span style="font-size: 120%;">n</span></span><span style="display: inline; color: rgb(150,0,0)"><em>k</em></span> <span style="display: inline; color: rgb(0,100,100)"><sub><span style="font-size: 120%;">y</span></sub></span><span style="display: inline; color: rgb(100,100,0)"><span style="font-size: 120%;">o</span></span><span style="display: inline; color: rgb(0,100,100)"><sub><span style="font-size: 120%;">u</span></sub></span>!</span></span></span></span></p></div>
<div style="text-align: center; color: inherit; font-size: inherit;"><p>last update: 2017-7-23</p></div>
</div></td></tr></table></center></body></html>