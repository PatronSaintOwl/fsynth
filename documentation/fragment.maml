$begin

$loadadm(maml_html5.adm)

$colorrule(funny)([a-e])($rgb(10,0,130)($sup($1)))
$colorrule(funny)([e-k])($rgb(150,0,0)($italic($1)))
$colorrule(funny)([l-p])($rgb(100,100,0)($big($1)))
$colorrule(funny)([p-z])($rgb(0,100,100)($sub($big($1))))
$colorizer(funny)

$colorrule(glsl)(void|const|float|int|vec2|vec3|vec4|if|else|continue|for|return|highp)($rgb(10,0,130)($1))
$colorrule(glsl)(##define|gl_FragColor|gl_FragCoord|clamp|pow|exp|mod|floor|sin|cos|tan|log)($rgb(0,100,0)($1))
$colorrule(glsl)(resolution|globalTime|htoy)($rgb(0,100,100)($1))
$colorrule(glsl)([0-9]+)($rgb(130,0,130)($1))
$colorrule(glsl)([0-9]+#.[0-9]*)($rgb(130,0,0)($1))
$colorrule(glsl)(#/#/.*)($rgb(60,20,20)($1))
$colorrule(glsl)(#*|#+|#-|#/|#==|#=|#<|#>|#+=|#*=)($rgb(10,100,80)($1))
$colorizer(glsl)

$define(glslcode)(1)($code(230,235,220)($colorize(glsl)($par$nolist($1)$par$par)))

$define(article)(0)()

$input(basis.maml)

$define(p)(0)($par$par)
$define(bigtitle)(1)($center($big($big($big($big($big($1)))))))
$define(title)(1)($center($big($big($1))))
$define(em)(1)($italic($1))

$bigtitle(Fragment)
$title(The Collaborative Spectral Synthesizer)
$par
$center(by Julien Verneuil - $mailto(contact@fsynth.com)(contact@fsynth.com))
$p$par

$center($big(This is the HTML documentation of the Fragment synthesizer.))

$par

$center($tlink($image(580)(images/fsynth_ui.png))(https://www.fsynth.com))

$par
$p
$center($bold(Table of Contents))$par
$tableofcontents

$section(introduction)(Introduction)

The $bold($tlink(Fragment synthesizer)(https://www.fsynth.com)) (also called fsynth) is a collaborative web-based musical instrument which allow direct manipulation of the sound spectrum by the use of on-the-fly GPU (Graphics Processing Unit) programming.
$p
Fragment is stereophonic, polyphonic, multitimbral and support live coding of audio and visuals at the same time.
$p
Fragment is first and foremost a powerfull additive synthesizer which let you have complete control over the sound spectrum in real-time with direct visual feedback.
$p

$subsection(history)(History)

$par

In 2009, i discovered the $tlink(Virtual ANS)(http://www.warmplace.ru/soft/ans/) synthesizer by $tlink(Alexander Zolotov)(http://www.warmplace.ru),
a software emulation of the Russian photoelectronic synthesizer $tlink(ANS)(http://en.wikipedia.org/wiki/ANS_synthesizer) which was created by the Russian engineer $tlink(Evgeny Murzin)(http://en.wikipedia.org/wiki/Evgeny_Murzin) from 1938 to 1958.
$p
I was blown away by the remarquable possibilities offered by the Virtual ANS which let you draw the sound spectrum over time, i then discovered programs such as MetaSynth or $tlink(HighC)(https://highc.org), this is how i started to experiment with the "drawn sound" method.
$p
Fragment started in 2015, when i was making the first prototype of a web-based ANS-like synthesizer software which is still a work in progress, a prototype of Fragment was made in a single week, 
the prototype was quite mature but lacked in features, i considered Fragment as a pretty but failed experiment at the time.
$p
In the summer 2016 while i was releasing the prototype source code, i played with it again and after tweaking the GLSL code, i was able to make some nice sounds and envision what would be possible with this technology, so i started to think about that prototype again and come up with many ideas that would make Fragment more functional and easier to use, the real work begun.
$p
After many hours spent crafting the software, the first version of Fragment was released in January 2017, it was quite limited at that time, Fragment has now improved alot.
$p

$subsection(capabilities)(Capabilities)

$list(
	$item Powerful additive synthesizer
		$list($item Powered by WebAudio oscillators $item Powered by $ref(fas)(FAS), an independent program $item Powered by a wavetable )
	$item Stereophonic
	$item Monaural
	$item Polyphonic
		$list($item Automatically detected from the GPU capabilities $item 16 notes minimum $item 704 notes with a GeForce GTX 970 GPU)
	$item Multitimbral
	$item Aliasing free
	$item Adjustable audio output channel per slices
		$list($item Multiple audio channels are only supported with $ref(fas)(FAS))
	$item Shader inputs, webcam, textures and more
	$item Real-time audio output analysis
		$list($item WebAudio only)
	$item MIDI Enabled
		$list($item Only with WebMIDI API enabled browsers (Google Chrome) $item Hot plugging of MIDI devices is supported)
	$item Collaborative app.
		$list($item MIDI and shader inputs are not synchronized between users)
	$item Live coding/JIT compilation of shader code
	$item Global and per sessions settings automatic saving/loading
	$item No authentifications (sessions based)
	$item Per-sessions discussion system)

$subsection(systemrequirements)(System requirements)

$par

Fragment is a special kind of additive synthesizer which require a great deal of processing power in order to work properly, a medium-end GPU and CPU should work fine.

$p

$subsubsection(browser)(Browser)

$par

Fragment require a browser with full support for ECMAScript 5, CSS3, WebAudio and WebGL.

$p
Well-tested and compatible browsers include Firefox 51.x and Chrome 55.x but Fragment may work with previous version of those browsers as well.
$p
It is known to work on recent version of Safari and Opera as well.
$p

Chrome or Chromium browser is recommended.

$p

Fragment support the WebGL 2 API which improve performances and enable some advanced features which are only available if the browser support the WebGL 2 API.

$p

$subsubsection(cpu)(CPU)

$par

Fragment may be quite hungry in term of computing resources, a dual core with high clock speed is recommended, a CPU with more cores can be useful if you just want to use the browser for audio output.
$p
Several methods are provided to synthesize sounds, each with performances pros and cons:
$par
$list(
	$item $ref(fas)(FAS) ($bold(recommended)): $list($item Very fast $item Multiple output support with soundcard choice $item Many settings $item Can run on a dedicated computer such as a Raspberry PI $item Dedicated program which receive Fragment data over the network)
	$item WebAudio oscillators: $list($item Fastest under Chrome $item May not work with Firefox $item Require a fast CPU $item Integrated global "release" envelope)
	$item Wavetable (not recommended): $list($item Most compatible browser method $item Will produce crackles))

$subsubsection(gpu)(GPU)

$par

Fragment was developed and tested with a NVIDIA GeForce GTX 970 GPU, a powerful GPU may be required if:
$par
$list(
	$item you want higher score resolution
	$item you want to do visuals alongside audio
	$item you are doing complex things/use many inputs in your shader
	$item you want greater polyphonic/harmonics capabilities)

$section(howitwork)(Concepts)

Fragment is an additive synthesizer, it let you have full control over the timbral qualities of your sounds by the mean of GPU programming.
$p
Unlike other additive synthesizer software, there is no need for knobs, sliders or any other controllers to sculpt your sounds, all of that is done by generating visuals which will determine your sounds harmonic content and dynamic characteristics.
$p
There is many features in Fragment which allow any creative minds to produce complex soundsc in different ways and even with external tools, i suggest all the readers to look at great softwares like the $tlink(IanniX sequencer)(https://www.iannix.org) and to use it with Fragment using the MIDI capabilities.
$p
While Fragment may seem overwhelming at first, the only thing that is required to produce sounds with it is to know how to generate the visuals.
$p
The goal of this section is to clarify the inner working of Fragment.
$p

$subsection(additive)(Additive synthesis)

$par

Fragment is first and foremost a powerful additive synthesizer which make an extended use of additive synthesis.
$p
Additive synthesis is a sound synthesis technique that creates timbre by adding sine waves together.
$p
Adding sine waves produce a timbre, the timbre qualities is mainly defined by its harmonic content and the dynamic characteristics of the harmonic content.
$p
Fragment can theoritically produce any timbres with precise accuracy.
$p
The only limit to the amount of sine waves that can be added by Fragment is the limit of the available processing power.
$p
For example, on a Raspberry PI 3 (1.2GHz 64-bit quad-core ARMv8 CPU) ~700 oscillators can be played simultaneously using two cores.
$p

$subsection(score)(The graphical score)

$par

Fragment graphical score represent the sound spectrum which is generated by the GPU from a fragment program.
$p
The fragment program (also known as fragment shaders) is executed by the GPU and compute the color and other attributes of each "fragment" - a technical term which usually mean a single pixel.
$p
The graphical score represent a kind of sonic canvas where the X axis represent time and the Y axis represent frequencies, you "paint" the graphical score by writing a fragment program which will be executed for each pixels of the graphical score.
$p
What you hear in Fragment is determined by the position of "slices" which are added on the graphical score, slices are vertical bits of the graphical score which are merged together and produce an audible result.
$p
The content of slices is captured at the rate of display refresh rate which conventionally should be 60fps most of the time.
$p
The frequency mapping of the graphical score is fixed by a logarithmic formula, altough the formula cannot be changed right now, some parameters are available in the settings dialog to fine tune the frequency map.
$p
The frequency mapping is defined by the formula:
$par

$latex($$f(y)=a*(2^{\frac{y}{n/o}})$$)

Where:

$list(
	$item $bold(a) is is the starting frequency
	$item $bold(y) the vertical position
	$item $bold(n) the number of oscillators (which is the height of the canvas)
	$item $bold(o) the octave count)
	
$section(sessions)(Sessions)

Fragment sessions are isolated spaces which are open to all peoples who has access to the session name, they can be joined by going to the Fragment $tlink(homepage)(https://www.fsynth.com) or by typing the session name directly into the address bar as demonstrated below.

$p

You can join any sessions directly from your browser address bar by replacing "yoursessionname" for the URL shown below by the session name you want to join or create:

$p

$center(https://www.fsynth.com/app/$bold(yoursessionname))

$par

Fragment store sessions content and settings on a server which mean that any of the synchronizable actions in the session such as the code editor content, canvas settings, slices and $ref(uniformsdialog)(uniform inputs) are automatically saved $bold(if) Fragment is connected.

$p

Fragment synchronize the code editor content, slices, canvas settings and $ref(uniformsdialog)(uniform inputs) across all the users in the session in real-time which mean that you can jam with your friends if you share the session URL.

$p

Note that MIDI note messages are not synchronized between users due to technical constraints but you can still add $ref(uniformsdialog)(uniform inputs) and assign MIDI devices to control them, their values are synchronized between users.

$p

Some settings are saved locally on your browser, some of them are global (like the username and settings related to the editor) and some of them are saved per sessions such as the MIDI settings and gain.

$p

Fragment is respectful of the user and does not store any informations related to the user outside the boundary defined by the application focus.

$p

$subsection(homepage)(Homepage and sessions history)

$par

The Fragment $tlink(homepage)(https://www.fsynth.com) can be used to retrieve the various sessions that you joined, a session list will be shown once you joined at least one session.

$tlink($center($image(600)(images/homepage_sessions.png)))(images/homepage_sessions.png)

$par

You can join a session from the list by clicking on it and by clicking on the door icon.

$p

You can remove a session from the list by clicking on it and by clicking on the trash icon.

$p

You can also clear the sessions history by clicking on the corresponding button, it will not delete the session content, just your settings for that session and the session will removed from the list, a deleted session can be joined back from the homepage form or by the browser address bar if you know its name.

$p

$section(fas)(FAS)

FAS (Fragment Audio Server) is the Fragment synthesis engine as a server, it is an external independent program written with the C language for very fast real-time audio synthesis.

$p

It is recommended to use Fragment with FAS enabled or use the standalone version of Fragment which include FAS.

$p

The advantage of using FAS is that it provide the best audio performances along with audio device choice, multiple audio output per slices, sample rate choice and realtime scheduling under Linux.

$p

Fragment communicate with FAS by sending data through the network when the FAS option is enabled, FAS can run on any machines independently of the Fragment application, it gather the pixels data from Fragment in real-time, compute things and deliver the audio through the selected audio device.

$p

FAS can be downloaded on the Fragment $tlink(homepage)(https://www.fsynth.com), it can also be compiled from sources on $tlink(GitHub)(https://github.com/grz0zrg/fas).

$p

FAS is provided as an executable for the following platforms at the moment:

$list(
	$item Windows x86/x64 32/64 bits
	$item Linux x86/x64 32/64 bits
	$item Raspberry PI (~700 oscillators can play at the same time under optimized system))

Here is a list of the program arguments which FAS support (along with the default settings if not provided):

$list(
	$item --h
	$list(
		$item show the program arguments)
	$item --device -1
	$list(
		$item the id of the audio device to use (running FAS without arguments once will print the devices found along with their id and informations))
	$item --iface 127.0.0.1
	$list(
		$item the address on which to listen)
	$item --port 3003
	$list(
		$item the network port on which to listen)
	$item --output_channels 2
	$list(
		$item the number of output channels, the value must be an even number)
	$item --alsa_realtime_scheduling 0
	$list(
		$item enable/disabled ALSA realtime scheduling, a Linux only parameter)
	$item --sample_rate 44100
	$list(
		$item can be any sample rate supported by the selected audio device)
	$item --frames 512
	$list(
		$item the audio buffer size, this have an effect on audio latency and CPU usage)
	$item --wavetable_size 8192
	$list(
		$item the wavetable size, the default value should be enough for most uses)
	$item --fps 60
	$list(
		$item this setting is provided in case Fragment does not capture slices at 60 fps, on most setup Fragment try to capture slices at 60 fps)
	$item --ssl 0
		$list(
			$item this is provided to use FAS over SSL (not recommended at all!))
	$item --max_height 4096
		$list(
			$item if you set the score height above 4096 pixels in Fragment, keep in mind that you must increase this!)
	$item --deflate 0
		$list(
			$item a value of 1 will enable deflate compressed packets (not recommended))
	$item --rx_buffer_size 4096
		$list(
			$item FAS will fragment packets which are bigger than the default value)
	$item --frames_queue_size 7
		$list(
			$item this is the length of the maximum number of frames waiting in the queue
			$item this is an important parameter, if you increase this too much the audio will be delayed)
	$item --commands_queue_size 16
		$list(
			$item this is the same as frames_queue_size except for commands (gain changes etc.)
			$item should be a power of 2 and positive integer))
	
Once run, you can stop the FAS application by pressing any keys.

$p

$section(gui)(The user interface)

$tlink($center($image(600)(images/ui_help.png)))(images/ui_help.png)
$tlink($center(Click to view the full image))(images/ui_help.png)

$p

Fragment user interface is quite easy to get once you figure out its layout.

$p

It is composed of a few parts with very specific roles, here is the list of parts along with detailed informations of their functions and supported actions.

$p

$subsection(dialogs)(Dialogs)

$par

There is many dialogs in Fragment, they are composed of a title bar with some actions, the dialog content and sometimes a status bar, dialogs hover above the rest of the application, you can move them around and close them, some are also resizable, minimizable and detachable in a separate window.

$p

To resize them, place your mouse cursor on the bottom left corner of the dialog, click and drag to the desired size.

$p

$tlink($center($image(600)(gif/dialog_resize.gif)))(gif/dialog_resize.gif)

$par

A mnimized dialog will take less space on the screen by only displaying the title bar.

$p

Here is a list of dialog actions (in the order by which they appear from left to right):

$p

$tlink($center($image(74)(images/dialog_actions.png)))(images/dialog_actions.png)

$list(
	$item close the dialog
	$item minimize/maximize
	$item detach the dialog in a new window)

$subsection(infobar)(The information bar)

$par

The information bar at the top convey minor and major informations such as (in order from left to right):

$list(
	$item connectivity status
	$list(
		$item a red indicator signal that the connection to this service failed
		$item the service name can be found by hovering the cursor on the icon)
	$item your online name
	$list(
		$item you can change your username by clicking on it)
	$item various informations which can be enabled or disabled in the settings dialog such as:
	$list(
		$item the current frequency under the mouse cursor
		$item the actual number of simultaneous MIDI notes
		$item the actual number of oscillators playing)
	$item the playback time
	$item a gain controller (master volume))

$subsection(graphicalscore)(The graphical score)

$par

You can slice the graphical score by right-clicking on it and clicking on the + icon, this will add a vertical bar which will capture that part of the canvas.

$p

$tlink($center($image(600)(gif/add_slices.gif)))(gif/add_slices.gif)

$par

You are free to add any number of slices, adding many slices may have an impact on performances.

$p

$subsubsection(graphicalscoreslice)(Slice)

$par

Slices are an important part of Fragment, there will be no sounds if you don't add at least one slice.

$p

The purpose of slices is to capture the pixels of vertical parts of the canvas which will be fed to the additive synthesis engine, they are like turntable needles, they can be dragged around in real-time by the mouse or by a MIDI controller, you can use programs like $tlink(IanniX)(https://www.iannix.org) to move them following certain kind of patterns.

$p

Slices can be moved by dragging them on the X axis, to do so, maintain the left mouse button on a slice and move the mouse cursor around on the horizontal axis.

$p

$tlink($center($image(600)(gif/dragging_slices.gif)))(gif/dragging_slices.gif)

$par

Double-clicking on a slice open its settings dialog directly:

$p

$tlink($center($image(326)(images/slice_settings.png)))(images/slice_settings.png)

$par

The following actions are possible by right-clicking on a slice:

$list(
	$item mute/unmute
	$list($item the synthesis engine will ignore a muted slice)
	$item open the slice settings which posses the following controllers:
	$list(
		$item X Offset: the slice horizontal position which can be controlled by a MIDI controller
		$item Y Shift: pitch the slice audio up or down (there is no visual representation of this)
		$item Increment per frame: This allow the slice to move left or right automatically, this is the increment value per frames
		$item $ref(fas)(FAS) Output channel: the l/r output channel which will be used by FAS for that slice)
	$item deletion)

Here is how you can mute a slice:

$p

$tlink($center($image(600)(gif/mute_slice.gif)))(gif/mute_slice.gif)

$par

Here is how you can delete a slice:

$p

$tlink($center($image(600)(gif/remove_slices.gif)))(gif/remove_slices.gif)

$par

$subsection(toolbar)(The toolbar)

$par

$tlink($center($image(574)(images/toolbar.png)))(images/toolbar.png)

$par

The toolbar is a collection of tools and settings which are grouped by sections, here is a detailed list of the toolbar items (in order from left to right):

$list(
	$item help
	$item social
	$list(
		$item session live chat
		$item direct link to the community board)
	$item settings
  $list(
  	$item $ref(globalsettingsdialog)(session and global settings)
  	$item $ref(midisettingsdialog)(MIDI settings))
  $item transport
  $list(
  	$item reset playback time to 0
  	$item play/pause
  	$item $ref(fas)(FAS enable/disable))
  $item helpers
  $list(
  	$item $tlink(ShaderToy)(https://www.shadertoy.com) converter
  	$item canvas axis details which appear when the canvas is hovered by the cursor
  	$item $ref(analysis)(analysis dialog) (not working when FAS is enabled)
  	$item clone the code editor in a separate window)
	$item fragment inputs
	$list(
		$item $ref(uniformsdialog)(uniforms)
		$item $ref(finputs)(add complex inputs)))

$subsection(finputs)(The fragment inputs)

$par

Fragment inputs are complex inputs which can be used in the fragment program as a 2D texture.

$p

The fragment inputs panel is a list of the added complex inputs, each of them appear as a thumbnail near the $bold(add complex inputs button), nothing will be shown if no complex inputs were added.

$p

All complex inputs can be used as 2D textures (texture2d) in the fragment program, they are defined as $bold(iInputN) where N is the id of the input starting from 0.

$p

You can find the input id by hovering over the thumbnail or in the title of the complex input settings dialog.

$p

You can add one by clicking on the "add complex inputs" button, here is a list of the available complex inputs:

$list(
	$item image file
	$item webcam
	$list(
		$item allow the real-time webcam video to be used in the fragment program)
	$item audio file)
	
By right clicking on a the complex input thumbnail, the following actions appear:

$list(
	$item delete
	$item complex input settings dialog)

$tlink($center($image(600)(gif/fragment_input.gif)))(gif/fragment_input.gif)
	
$par
	
The complex input settings dialog have several options:

$par

$list(
	$item filter
	$list(
		$item nearest: no interpolation
		$item linear: linear interpolation)
	$item Wrap S
	$list(
		$item clamp: stop horizontally when outside the (0,0) to (1,1) range
		$item repeat: repeat horizontally when outside the (0,0) to (1,1) range
		$item mirrored repeat: same as repeat but mirrored)
	$item Wrap T
	$list(
		$item clamp: stop vertically when outside the (0,0) to (1,1) range
		$item repeat: repeat vertically when outside the (0,0) to (1,1) range
		$item mirrored repeat: same as repeat but mirrored)
	$item VFlip: flip the texture vertically)

Note: The "repeat" and "mirrored" Wrap S/T option will be unavailable if your browser does not support the WebGL 2 API, it is only available by adding images with power-of-2 dimensions (128x64, 256x256 etc.) or by using a browser with WebGL 2 support.

$p

$subsection(analysis)(Analysis dialog)

$par

The analysis dialog is a real-time spectogram view of the audio output.

$p

Note: When FAS is enabled, no spectrogram will be shown.

$p

$tlink($center($image(600)(gif/analysis_dialog.gif)))(gif/analysis_dialog.gif)

$par

$subsection(codeditor)(The code editor)

$par

The fragment editor is one of the most important tool of Fragment since it allow the user to generate the visuals which are fed to the additive synthesis engine.

$p

$tlink(GLSL)(https://www.khronos.org/files/opengles_shading_language.pdf) code is what you type in the code editor to generate the visuals.

$p

The fragment program is compiled as you type, if the compilation fail, the code editor will notice you with a floating message and with a red message at the lines that cause the compilation to fail, all of that without interrupting sounds/visuals output, this enable powerful live coding.

$p

$tlink($center($image(600)(gif/glsl_inline_report.gif)))(gif/glsl_inline_report.gif)

$par

The changes that you make in the code editor are automatically saved per named sessions, changes are also synchronized in real-time between all the users of the session you are currently in, this is the collaborative nature of Fragment.

$p

The code editor is powered by the CodeMirror library, it feature many neat things such as:

$list(
	$item GLSL syntax highlighting
	$item highlight matches
	$item brackets/parentheses opening/end highlights
	$item fullscreen editor by pressing F11
	$item integrated compilation errors/messages (does not interrupt sounds/visuals)
	$item line numbers
	$item many bundled editor themes)
	
Some of the code editor features can be enabled/disabled in the $ref(globalsettingsdialog)(global settings dialog).

$p

If you experience audio stuttering as you type, it is recommended to detach the code editor off the main window, due to the complexity of the web and the complexity of the Fragment application, many things are not as optimal as they should be, you may hear audio crackles due to browser reflow.

$p

$subsection(midilearn)(MIDI learn functionality)

$par

MIDI learn is a neat feature of Fragment which enable any MIDI learn enabled widget to be controlled by a MIDI controller.

$p

$tlink($center($image(104)(images/midi_learn.png)))(images/midi_learn.png)
$center(The red square indicate MIDI learn functionality support for this widget)

$par

The red square appearing on an UI interface widget indicate that the MIDI learn functionality is supported for the widget, it only appear on WebMIDI enabled browsers such as Chrome and Opera and on widgets which are allowed to be controlled by MIDI.

$p

By left clicking on the red square, it turn green and any inputs from the $ref(midisettingsdialog)(enabled MIDI devices) will be captured by the widget.

$p

Once the MIDI input is captured, the green square become red again (which is a locked state) and the MIDI control will be assigned to the widget.

$p

It is possible to reset the MIDI control assigned to the widget by clicking on the red square and clicking again on the green square aka double clicking.

$p

$subsection(globalsettingsdialog)(The session/global settings dialog)

$par

$tlink($center($image(347)(images/settings.png)))(images/settings.png)

$par

The session & global settings dialog content (in order from top to bottom):

$list(
	$item Score width
	$list(
		$item The score width in pixels units)
	$item Score height
	$list(
		$item The score height in pixels units
		$item Higher height = better resolution in term of frequencies)
	$item Score base frequency
	$list(
		$item Determine the base frequency in hertz units)
	$item Score octave range
	$list(
		$item Control the range of frequencies)
	$item Osc. fadeout
	$list(
		$item WebAudio fadeout time (like "release" parameter in other synts, WebAudio oscillators only))
	$item Polyphony
	$list(
		$item Maximum polyphony)
	$item Show globalTime
	$list(
		$item Hide/Show the globalTime in the informations bar)
	$item Show osc. infos
	$list(
		$item Hide/Show the number of oscillators playing simultaneously in the informations bar)
	$item Show poly. infos
	$list(
		$item Hide/Show the polyphony infos for per output channels in the informations bar)
	$item Show slices bar
	$list(
		$item Hide/Show slices vertical bar)
	$item Show line numbers
	$list(
		$item Hide/Show the line number in the code editor)
	$item Advanced scrollbar
	$list(
		$item Enable/disable a better looking scrollbar for the code editor)
	$item Highlight matches
	$list(
		$item Enable/disable matches highlight in the code editor (when something is selected))
	$item Show slices
	$list(
		$item Hide/Show slices, can be useful for visuals, this settings is not saved)
	$item Monophonic
	$list(
		$item Enable/disable monophonic mode
		$item If monophonic is enabled, only the alpha value is used by the synthesis engine, the full RGB output can then be used for visuals)
	$item Wavetable
	$list(
		$item Enable/disable the synthesis engine wavetable feature (uglier audio output but may be the less CPU intensive mode))
	$item Editor theme
	$list(
		$item A list of themes for the code editor)
	$item FAS address
	$list(
		$item The location of $ref(fas)(FAS (Fragment Audio Server)) on the network))

$subsection(midisettingsdialog)(MIDI settings dialog)

$par

$tlink($center($image(325)(images/midi_settings.png)))(images/midi_settings.png)

$par

The MIDI settings dialog show all the MIDI input devices found at this time, by default there is no MIDI input devices enabled, you can enable MIDI devices by checking the checkbox below the MIDI device name.

$p

Once enabled, Fragment will receive any MIDI messages from that device.

$p

Fragment support hot plugging of MIDI devices, any MIDI devices which are plugged or unplugged while Fragment is running will be added or removed in the MIDI settings dialog.

$p

Fragment keep track of your MIDI settings choice for particual devices per sessions, this mean that if a MIDI device is enabled, when you quit Fragment or that the MIDI device is unplugged and you launch again Fragment and that the MIDI device is plugged in, Fragment will enable it automatically.

$p

$subsection(sessionchat)(Session chat dialog)

$par

$tlink($center($image(600)(images/session_chat.png)))(images/session_chat.png)

$par

The session chat dialog allow discussions with all users in the current session.

$p

It is a simple but effective chatbox that you can resize, move around or detach. it has three parts:

$list(
	$item messages list
	$item users list
	$item input)

The green user in the user list indicate yourself.

$p

You can send a message to all users in the session by clicking on the input then typing your message and pressing ENTER.

$p

$subsection(uniformsdialog)(Uniforms dialog)

$par

The uniforms dialog is a very powerful functionality.

$p

It enable you to define fragment program uniforms (aka variables) which are synced with all users in the session and are controllable by any MIDI input devices enabled.

$p

All the uniforms added will be shown in the uniforms dialog and will be defined automatically in the fragment program, you can then just use the symbol name in the code editor.

$p

You can add the following scalar uniforms types:

$list(
	$item bool
	$item int
	$item float)
	
If count is higher than 1, Fragment will add the scalar uniforms as an array.

$p
	
You can also add vector uniforms of the following types (note: the components field determine the number of components for the following uniform type):

$list(
	$item bvec2
	$item bvec3
	$item bvec4
	$item ivec2
	$item ivec3
	$item ivec4
	$item vec2
	$item vec3
	$item vec4)

If count is higher than 1, Fragment will add the vector uniforms as an array.

$p

$section(gpuprogramming)(How to produce sounds by programming your GPU)

Fragment usage of the GPU is restricted to a single fragment program which will be executed by the GPU for each pixels of the graphical score.

$p

The fragment program is written in GLSL (OpenGL Shading Language) which has a syntax quite similar to the C language but is much simpler to learn.

$p

You can do anything from ray-traced 3D to drawing simple lines and define their behaviors with Fragment, the only requirement is high school mathematics.

$p

This documentation focus on the audio synthesis aspect of Fragment as there is already plenty resources covering the creation of stunning visuals with GLSL programs on the web.

$p

There is also many applications that let you create stunning visuals in your browser by the same method, one of the most popular one and compatible with Fragment (by using the convert ShaderToy button of the toolbar) is $tlink(ShaderToy)(https://www.shadertoy.com/), this program let you build visuals and audio at the same time, just like Fragment but with a more conventional approach to audio synthesis.

$p

$subsection(glsles)(OpenGL Shading Language)

$par

The Khronos Group (authors of the language specification) released several reference cards of the GLSL specification, the reference cards are compact reference of the full language specification which can be used in conjunctions with code samples to learn the OpenGL Shading Language quickly.

$p

Since there is plenty of resources to learn the OpenGL Shading Language, the documentation provided in this section will only provide the official reference cards which are enough to learn from to understand all the GLSL code that will follow.

$p

As Fragment can use WebGL 2.0 if your browser has support for it, the reference cards for both WebGL 1.0 GLSL and WebGL 2.0 GLSL (more functionalities) is provided, keep in mind that if Fragment run fine with your browser, you can safely use the WebGL 1.0 GLSL reference card as a starting point:

$list(
	$item WebGL 1.0 OpenGL Shading Language
	$list(
		$item $tlink(Page 1 PDF)(pdf/webgl1_glsl_1.pdf)
		$item $tlink(Page 2 PDF)(pdf/webgl1_glsl_2.pdf)))

$list(
	$item WebGL 2.0 OpenGL Shading Language
	$list(
		$item $tlink(Page 1 PDF)(pdf/webgl2_glsl_1.pdf)
		$item $tlink(Page 2 PDF)(pdf/webgl2_glsl_2.pdf)
		$item $tlink(Page 3 PDF)(pdf/webgl2_glsl_3.pdf))
)

Here is a simple example of GLSL code that Fragment accept which just set all pixels to black:

$glslcode(
  void main () {
    gl_FragColor = vec4(0., 0., 0., 0.);
  }
)

In the subsequent GLSL code, $rgb(10,0,130)(blue words) are GLSL keywords, $rgb(130,0,0)(red) are float values and $rgb(0,130,0)(green words) are pre-defined specific definitions or functions.

$p

$subsection(predefuniforms)(Pre-defined uniforms)

$par

Fragment has many pre-defined uniform variables which can be used to animate/modulate things, here are all the pre-defined uniforms along with their type that can be used directly in your code:

$list(
	$item $bold(vec2) $rgb(0,100,100)(resolution)
	$list(
		$item score/viewport resolution in pixels units)
	$item $bold(float) $rgb(0,100,100)(globalTime)
	$list(
		$item playback time in seconds)
	$item $bold(float) $rgb(0,100,100)(baseFrequency)
	$list(
		$item score base frequency)
	$item $bold(float) $rgb(0,100,100)(octave)
	$list(
		$item score octave range)
	$item $bold(vec4) $rgb(0,100,100)(mouse)
	$list(
		$item mouse pixel coords updated when the left mouse button is down on the canvas)
	$item $bold(vec4) $rgb(0,100,100)(date)
	$list(
		$item year
		$item month
		$item day
		$item time in seconds)
	$item $bold(sampler2D) $rgb(0,100,100)(iInput)$rgb(0,100,100)($bold(N))
	$list(
		$item typical usage: texture2D(iInput0, uv))
	$item $bold(vec4[N]) $rgb(0,100,100)(keyboard)
	$list(
		$item note-on frequency
		$item note-on velocity
		$item note-on elapsed time
		$item note-on MIDI channel)
	$item $bold(function) $rgb(0,100,100)(htoy)
	$list(
		$item take a frequency as argument and return its normalized vertical position on the canvas)
)
	
$subsection(harmonics)(The timbre)

$par

It is difficult to define precisely the attributes of a complex sound, simplistic models would say that all complex sounds are a combination of a fundamental frequency and the harmonics which are integer multiple of the fundamental frequency but as you can find on the $tlink(Wikipedia article on timbre)(https://en.wikipedia.org/wiki/Timbre), there is many more attributes.

$p

Here is an excerpt of timbre major attributes by Robert Erickson taken from the Wikipedia page:

$list(
	$item The range between tonal and noiselike character
	$item The spectral envelope
	$item The time envelope in terms of rise, duration, and decay
	$item The changes both of spectral envelope (formant-glide) and fundamental frequency (micro-intonation)
	$item The prefix, or onset of a sound, quite dissimilar to the ensuing lasting vibration)

$subsection(linedrawing)(Drawing the fundamental)

$par

The fundamental is the simplest constituent of our timbre (its pitch and lowest frequency) and also the fundamental basis for building the harmonics (also called overtones) etc.

$p

We will produce a fundamental by drawing a horizontal lines and later on its harmonics, all of that will constitute all the frequencies contained by our sound (aka harmonics, partials etc.), those horizontal lines will have several conditional transformations and other processing applied to them later on to produce complex sounds.

$p

Here is how to draw a horizontal line which will produce a fundamental 440Hz sine wave:

$par

$glslcode(
  void main () {
    // get normalized coordinates [0, 1] of the current fragment (pixel)
    vec2 uv = gl_FragCoord.xy / resolution;
    
    float frequency = 440.;
    float l = 0.;
    float r = 0.;
    
    // because this code is executed for each fragments
    // the horizontal line is defined mathematically
    // by a simple function: y^2 where y is offseted
    // by the normalized vertical position of our 440Hz frequency
    float v = pow(uv.y - htoy(frequency), 2.);
    
    // we will increase the steepness of the previous function
    // we "catch" our vertical position with the function: y^2 * b
    // this is like an imperfect narrow bandpass filter
    // but just narrow enough so that only our line come "up"
    float bandwidth = 700000.;
    v *= bandwidth;
    
    // generate the color for left and right channels aka red and green output color
    // we take care of reversing the value so that the line is seen
    // we also clamp it to [0, 1], this is a safety measure for later on
    l += clamp(1. - v, 0., 1.);
    r += clamp(1. - v, 0., 1.);
    
    // plot the line
    // Fragment use the RED and GREEN component
    // for the LEFT and RIGHT audio channel in stereophonic mode
    // if monophonic mode is enabled, the alpha component will be used for the audio
    // in this case all other components are unused
    // thus the blue component can be used for visuals or debugging etc.
    gl_FragColor = vec4(l, r, 0., 0.);
  }
)

$par

Where:

$list(
	$item $bold($rgb(0,100,100)(resolution)) is a pre-defined Fragment uniform of type vec2 which contain the score $bold(width) and $bold(height)
	$item $bold($rgb(0,100,100)(htoy)) is a pre-defined Fragment function which take a frequency in Hertz as argument and output its score $bold(normalized vertical position)
)

If you have troubles understanding this code, i urge you to plot all the functions in a normalized space with a tool such as $tlink(desmos)(https://www.desmos.com/calculator), keep in mind that this code is run for every pixels!

$p

You can verify that the produced horizontal line is a 440Hz sine wave by enabling the axis details tool in the toolbar and point your cursor on the horizontal line:

$p

$tlink($center($image(600)(gif/freq_details.gif)))(gif/freq_details.gif)

$par

You might be surprised to see that this is actually not exactly a 440Hz sine wave, the value is rounded due to the way $ref(score)(frequencies are mapped), this can be fixed by increasing the score height to get a more precise mapping, this will require higher processing power however.

$par

The function that we use here is also imperfect even if it work in most cases and has good performances, it is imperfect because at some frequencies, the color intensity of our horizontal will be shared on frequencies "in between", this is due to the mathematical function that we use, this can be attenuated by lowering the bandwidth but doing that may actually have the inverse effect, drawing a perfect horizontal line in all cases with a fragment shader can be quite tricky altough not impossible.

$p

$subsection(harmonics)(Drawing harmonics)

$par

Harmonics are defined as positive integer multiple of the frequency of the fundamental.

$p

We will extend the previous code by adding a loop:

$par

$glslcode(
  void main () {
    vec2 uv = gl_FragCoord.xy / resolution;
    
    float l = 0.;
    float r = 0.;
    float base_frequency = 440.;
    float bandwidth = 700000.;
    
    // the number of harmonics that we want (including the fundamental)
    // we define it as "const" because the current GLSL spec.
    // does not allow dynamic variables for loops index
    const float harmonics = 8.;
    
    // draw a horizontal line for each harmonics
    // including the fundamental (that is why it is starting at 1.)
    for (float i = 1.; i < harmonics; i += 1.) {
      // multiply the fundamental frequency by the index of the current harmonic
      float v = pow(uv.y - htoy(base_frequency * i), 2.);

      v *= bandwidth;

      l += clamp(1. - v, 0., 1.);
      r += clamp(1. - v, 0., 1.);
    }
    
    gl_FragColor = vec4(l, r, 0., 0.);
  }
)

$par

The produced timbre is actually too raw because all our harmonics have the same value...

$p

We can fix that by attenuating the higher frequencies, an exponential attenuation provide good results generally in audio due to the way humans brain interpret sounds, we could also just attribute different intensity for each of our harmonics:

$par

$glslcode(
  void main () {
    vec2 uv = gl_FragCoord.xy / resolution;
    
    float l = 0.;
    float r = 0.;
    float base_frequency = 440.;
    float bandwidth = 700000.;
    
    float attenuation_constant = 1.95;
    
    const float harmonics = 8.;
    
    for (float i = 1.; i < harmonics; i += 1.) {
      // exponentially attenuate higher frequencies
      float a = 1. / pow(i, attenuation_constant);
      float v = pow(uv.y - htoy(base_frequency * i), 2.);

      v *= bandwidth;

      l += clamp(1. - v, 0., 1.) * a;
      r += clamp(1. - v, 0., 1.) * a;
    }
    
    gl_FragColor = vec4(l, r, 0., 0.);
  }
)

$par

The output is now smoother, our simple timbre sound much better... we will see next how we can play our simple timbre with a MIDI keyboard.

$p

$subsection(midiplay)(Playing with a MIDI keyboard)

$par

You must have a WebMIDI supported browser (such as Chrome or Opera) to use MIDI messages with Fragment.

$p

Once your MIDI keyboard is plugged in, you can go in the Fragment MIDI devices and enable it.

$p

The MIDI data will now be available in a pre-defined $bold(vec4 array) named $bold(keyboard), the array length is the actual polyphony capability of Fragment, the array contain a series of vec4 items, a vec4 item contain:

$list(
	$item the note-on frequency
	$item the note velocity
	$item the elapsed time since the key was pressed
	$item the MIDI channel)

Important note: There is no notions of "note-off" in Fragment, a note-off is simply an item filled with 0, Fragment will add note-on in order and will reorder the array as necessary, this mean that you can loop over all items and break the loop if an item component is equal to 0.

$p

Here is how you can use your MIDI keyboard:

$par

$glslcode(
  void main () {
    vec2 uv = gl_FragCoord.xy / resolution;
    
    float l = 0.;
    float r = 0.;
    float bandwidth = 700000.;
    
    float attenuation_constant = 1.95;
    
    const float harmonics = 8.;
    
    // 8 notes polyphony
    // this can be increased up to the maximal polyphonic capabilities
    // of Fragment for your platform
    for (int k = 0; k < 8; k += 1) {
    	// we get the note-on data
      vec4 data = keyboard[k];
      
      float kfrq = data.x; // frequency
      float kvel = data.y; // velocity
      float ktim = data.z; // elpased time
      float kchn = data.w; // channel
      
      // we quit as soon as there is no more note-on data
      // this is optional but it might help with performances
      // so we don't compute harmonics uselessly
      if (kfrq == 0.) {
       	break; 
      }
      
      for (float i = 1.; i < harmonics; i += 1.) {
        float a = 1. / pow(i, attenuation_constant);
        // we apply the note-on frequency
        float v = pow(uv.y - htoy(kfrq * i), 2.);

        v *= bandwidth;

        // we apply the velocity
        l += clamp(1. - v, 0., 1.) * a * kvel;
        r += clamp(1. - v, 0., 1.) * a * kvel;
      }
    }
    
    // notice how the blue channel is used
    // this help to get a better visual feedback of the harmonics
    gl_FragColor = vec4(l, r, l * 64., 0.);
  }
)

$par

You can now play something with your MIDI keyboard and hear your basic timbre!

$p

You might find the loop kind of weird, why we don't just loop over all note-on messages? This is because the GLSL spec. for the version that is used by the browsers is quite limited when it come to loop features... for example, it does not allow dynamicals indexes.

$p

$subsection(envelope)(Simple AR-like envelope)

$par

Our timbre is nice but still too simple, we can fix that by applying an envelope, a mathematical function which will determine the timbre behaviors by taking into account the elapsed time when we hit the keys of our MIDI keyboard.

$p

Fragment allow any envelopes to be done by mathematically defining them, one of the simplest envelope is AR (Attack and Release):

$par

$glslcode(
  // a simple function which define 
  // smooth AR-like envelopes, fast attack and slow decays
  // plot it or see the details of this function below
  // it's maximum, which is 1.0, happens at exactly x = 1 / k
  // use k to control the stretching of the function
  float impulse(float k, float x) {
    float h = k * x;
    return h * exp(1.0 - h);
  }

  void main () {
    vec2 uv = gl_FragCoord.xy / resolution;
    
    float l = 0.;
    float r = 0.;
    float bandwidth = 700000.;
    
    float attenuation_constant = 1.95;
    
    const float harmonics = 8.;
    
    for (int k = 0; k < 8; k += 1) {
      vec4 data = keyboard[k];
      
      float kfrq = data.x;
      float kvel = data.y;
      float ktim = data.z;
      float kchn = data.w;
      
      if (kfrq == 0.) {
       	break; 
      }
      
      // we apply the envelope, this envelope has a fast attack
      // of 62.5ms and a release of 555ms
      float env_attack = ktim * 16.;
      float env = kvel * impulse(1., env_attack);
      
      for (float i = 1.; i < harmonics; i += 1.) {
        float a = 1. / pow(i, attenuation_constant);
        float v = pow(uv.y - htoy(kfrq * i), 2.);

        v *= bandwidth;

        l += (clamp(1. - v, 0., 1.) * a * env);
        r += (clamp(1. - v, 0., 1.) * a * env);
      }
    }
    
    gl_FragColor = vec4(l, r, l + r, 0.);
  }
)

$par

The sound is much more pleasant! You can change the parameters of the envelope to apply other kinds of envelopes.

$p

Here is a good preview of the envelope models that the $bold(impulse) function generate:

$p

$tlink($center($image(512)(images/impulse.png)))(images/impulse.png)

The sound is still not very interesting yet but now that we know how to generate the envelope, we can do many things such as applying a different envelope to each harmonics:

$par

$glslcode(
  float impulse(float k, float x) {
    float h = k * x;
    return h * exp(1.0 - h);
  }

  void main () {
    vec2 uv = gl_FragCoord.xy / resolution;
    
    float l = 0.;
    float r = 0.;
    float bandwidth = 700000.;
    
    float attenuation_constant = 1.95;
    
    // we will now increase the amount of harmonics
    const float harmonics = 16.;
    
    for (int k = 0; k < 8; k += 1) {
      vec4 data = keyboard[k];
      
      float kfrq = data.x;
      float kvel = data.y;
      float ktim = data.z;
      float kchn = data.w;
      
      if (kfrq == 0.) {
       	break; 
      }

      float env_attack = ktim * 16.;
      
      for (float i = 1.; i < harmonics; i += 1.) {
        float a = 1. / pow(i, attenuation_constant);
        float v = pow(uv.y - htoy(kfrq * i), 2.);

        v *= bandwidth;
        
        // we stretch the envelope per harmonics
        float env_stretch = i / harmonics;
        float env = kvel * impulse(env_stretch, env_attack);

        l += (clamp(1. - v, 0., 1.) * a * env);
        r += (clamp(1. - v, 0., 1.) * a * env);
      }
    }
    
    gl_FragColor = vec4(l, r, l + r, 0.);
  }
)

$par

The timbre produced by this code is very pleasant, all high frequencies harmonics decay very fast while the fundamental decay slowly, you can hear multiple versions of this by varying parameters such as the attack time or the attenuation constant etc., a very fast attack time sound very pleasant now.

$p

$subsection(morphing)(Morphing between parameters)

$par

We will now look into getting a better timbre by morphing parameters such at the attenuation or frequencies, due to the nature of Fragment, almost everything can be morphed easily by using mathematical functions:

$par

$glslcode(
  float impulse(float k, float x) {
    float h = k * x;
    return h * exp(1.0 - h);
  }

  void main () {
    vec2 uv = gl_FragCoord.xy / resolution;
    
    float l = 0.;
    float r = 0.;
    float bandwidth = 700000.;
    
    float attenuation_constant = 1.95;
    
    const float harmonics = 16.;
    
    for (int k = 0; k < 8; k += 1) {
      vec4 data = keyboard[k];
      
      float kfrq = data.x;
      float kvel = data.y;
      float ktim = data.z;
      float kchn = data.w;
      
      if (kfrq == 0.) {
       	break; 
      }

      float env_attack = ktim * 16.;
      
      // we create a mixing function
      float mix_f = 0.5 * (1. + sin(ktim * 20.));
      
      for (float i = 1.; i < harmonics; i += 1.) {
        float a = 1. / pow(i, attenuation_constant);
        
        // we setup another attenuation value which
        // is a bit higher than the previous one
        float a2 = 1. / pow(i, attenuation_constant * 1.3);
        
        float v = pow(uv.y - htoy(kfrq * i), 2.);
        
        v *= bandwidth;
        
        float env_stretch = i / harmonics;
        float env = impulse(env_stretch, env_attack);

        // we now mix our attenuations so that
        // higher harmonics oscillate between both 
        // kind of attenuations smoothly
        a = mix(a, a2, mix_f);

        l += (clamp(1. - v, 0., 1.) * a * env);
        r += (clamp(1. - v, 0., 1.) * a * env);
      }
    }
    
    gl_FragColor = vec4(l, r, l + r, 0.);
  }
)

$par

This sound just nice! This is just an example but you can now imagine the amount of possibilities, very complex timbres can be created easily by applying custom functions and mixing between several parameters!

$par

Fragment offer a limitless landscape for any creative minds willing to experiment.

$par

We could have some fun by also varying the frequency per harmonics etc.

$p

$subsection(sequence)(Sequence)

$par

We will see in this section how to do a 16 or N steps sequences with Fragment, we will use the $ref(uniformsdialog)(uniforms dialog) to define an array of values which will hold the frequency data of our sequence.

$p

You can do that by opening the $ref(uniformsdialog)(uniforms dialog) and then adding an array of uniforms named $bold(sequence) as pictured below:

$p

$tlink($center($image(235)(images/sequence.png)))(images/sequence.png)

$par

Many values should appear now in the uniforms dialog, you can change the frequency value for each steps with your keyboard, mouse or by assigning a MIDI control to each steps.

$p

Here is the code to play a sequence automatically:

$par

$glslcode(
// we define the PI constant
// note: the "#define" keyword cannot start on the very first line
#define pi 3.141592653

float impulse(float k, float x) {
    float h = k * x;
    return h * exp(1.0 - h);
}

void main () {
    vec2 uv = gl_FragCoord.xy / resolution;
    
    float l = 0.;
    float r = 0.;
    float base_frequency = 440.;
    float bandwidth = 700000.;
  
    // we just redefine globalTime for convenience
    // globalTime is a pre-defined Fragment uniform
    // which hold the time since Fragment started to play
    // you can "rewind" it by clicking on the corresponding toolbar button
    float time = globalTime;
    
    // increase the number of harmonics so we get a richer sound
    const float harmonics = 16.;

    // we will override "keyboard" because GLSL
    // does not permit us to assign by index dynamically
    // we will have 8 notes polyphony (copied from "keyboard" + the sequence)
    vec4 notes[9];
  	
    // our sequence have 16 steps
    float seq_length = 16.;
  
    // we use the "mod" function with the length of the sequence
    // this play our sequence over and over, 4 notes per seconds
    int seq_index = int(floor(mod(time * 4., seq_length)));

    // this is a GLSL trick to get the current step frequency
    // we do that because "sequence[seq_index]" is not accepted
    // this is a limitation of the current WebGL spec.
    // which do not allow dynamical indexes for arrays...
    float seq_frq = 0.;
    for (int k = 0; k < 16; k += 1) {
      if (k == seq_index) {
        seq_frq = sequence[k];
      }
    }

    // now we just copy 8 notes from the "keyboard" array
    // which will allow us to play 8 notes at the same time
    // with a MIDI keyboard
    for (int k = 0; k < 8; k += 1) {
      notes[k] = keyboard[k];
    }

    // we assign the current sequence note
    // notice how we make the note duration
    // perfectly fit within its lifetime
    // it goes on, hit its peak and go down
    // before passing to the next
    notes[9] = vec4(seq_frq, 1., 0.5 * (1. + sin((pi * 1.5) + 2. * pi * time)), 0.);
    
    // we loop over our 9 notes
    for (int k = 0; k < 9; k += 1) {
      // notice that we no more use "keyboard"
      // but our overriden "keyboard" array with our sequence within
      vec4 data = notes[k];
      
      float kfrq = data.x;
      float kvel = data.y;
      float ktim = data.z;
      float kchn = data.w;

      float env = kvel * impulse(1., ktim);
      
      for (float i = 1.; i < harmonics; i += 1.) {
        float a = 1. / pow(i, 1.95);
        float v = pow(uv.y - htoy(kfrq * i), 2.);

        v *= bandwidth;

        l += (clamp(1. - v, 0., 1.) * a * env);
        r += (clamp(1. - v, 0., 1.) * a * env);
      }
    }
    
    gl_FragColor = vec4(l, r, 0., 0.);
  }
)

$par

You should hear a sequence of notes which you can play along with a MIDI keyboard.

$p

An autonomous sequence is relatively easy and can also be done by using the $bold(mod) function.

$p

We strongly recommend that peoples use Fragment with a MIDI sequencer such as $tlink(LMMS)(https://www.lmms.io), $tlink(IanniX)(https://www.iannix.org), $tlink(Renoise)(https://www.renoise.com/), $tlink(MusE)(http://muse-sequencer.org) or any other MIDI capable sequencers, sequences can be done very easily within a sequencer and many effects can be added to the audio output.

$p

$subsection(globaltime)(Note on globalTime)

$par

The global time is one of the most important pre-defined variable in Fragment, it is a playback time that increase continually as soon as you hit the play button on the toolbar, it can only be reset or paused by using the corresponding toolbar button, the global time is a precise clock which can be used to trigger events and dynamically alter the visuals.

$p

$section(contribute)(Contributing)

Fragment is a free and open source software released under the term of the BSDv2 license.

$p

Any contributions from the documentation to the synthesis engine are welcome!

$p

The source code is available on $tlink(GitHub)(https://github.com/grz0zrg/fsynth).

$par

$ref(fas)(FAS) source code is also available on $tlink(GitHub)(https://github.com/grz0zrg/fas).

$p

$section(links)(Links)

$list(
	$item $tlink(Fragment Synthesizer website)(https://www.fsynth.com)
	$item $tlink(Fragment Synthesizer forum)(https://quiet.fsynth.com)
	$item $tlink(Fragment source code)(https://github.com/grz0zrg/fsynth)
	$item $tlink(FAS source code)(https://github.com/grz0zrg/fas)
	$item $tlink(Facebook)(https://www.facebook.com/fsynth/)
	$item $tlink(YouTube)(https://www.youtube.com/channel/UC2CJFT1_ybPcTNlT6bVG0WQ)
	$item $tlink(Twitter)(https://twitter.com/fragmentsynth)
	$item $tlink(SoundCloud)(https://soundcloud.com/fsynth/))
	
$section(credits)(Credits)

$list(
	$item Testing: $list($item Franz Khrum)
	$item Ideas: $list(
		$item $tlink(Virtual ANS)(http://www.warmplace.ru/soft/ans/)
		$item $tlink(ShaderToy)(https://www.shadertoy.com/))
	$item Tools: $list(
		$item $tlink(The Anubis programming language)(http://redmine.anubis-language.com/)
		$item $tlink(Inkscape)(https://www.inkscape.org)
		$item $tlink(Geogebra)(https://www.geogebra.org)
		$item $tlink(The GIMP)(https://www.gimp.org)
		$item $tlink(KDEnlive)(https://kdenlive.org)
		$item $tlink(SimpleScreenRecorder)(http://www.maartenbaert.be/simplescreenrecorder/)
		$item $tlink(libflds)(http://liblfds.org)
		$item $tlink(portaudio)(http://www.portaudio.com)
		$item $tlink(libwebsockets)(https://libwebsockets.org)
		$item $tlink(Brackets)(http://brackets.io/)
		$item $tlink(fa2png)(http://fa2png.io/)
		$item $tlink(FontAwesome)(http://fontawesome.io/)
		$item $tlink(CodeMirror)(http://codemirror.net/)
		$item $tlink(ShareDB)(https://github.com/share/sharedb/)
		$item $tlink(live-server)(https://www.npmjs.com/package/live-server)
		$item $tlink(Normalize)(https://necolas.github.io/normalize.css/)
		$item $tlink(Skeleton)(http://getskeleton.com/)
		$item $tlink(NodeJS)(https://nodejs.org/en/)
		$item $tlink(NGINX)(https://www.nginx.com/)
		$item $tlink(Flarum)(http://flarum.org/)
		$item $tlink(pm2)(https://github.com/Unitech/pm2)
		$item $tlink(MongoDB)(https://www.mongodb.com/)
		$item $tlink(Redis)(https://redis.io/)
		$item $tlink(Winston)(https://github.com/winstonjs/winston)
		$item $tlink(Express)(http://expressjs.com/)
		$item $tlink(strong-cluster-control)(https://github.com/strongloop/strong-cluster-control)))
$par

$center($big($big($big($big($colorize(funny)(Thank you!))))))
$par
$center(last update: 2017-05-03)

$end